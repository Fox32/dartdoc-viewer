"name" : "dart.async"
"comment" : ""
"variables" : 
  "_asyncCallbacks" : 
    "name" : "_asyncCallbacks"
    "qualifiedname" : "dart.async._asyncCallbacks"
    "comment" : ""
    "final" : "false"
    "static" : "false"
    "type" : "dart.collection.Queue"
  "_callbacksAreEnqueued" : 
    "name" : "_callbacksAreEnqueued"
    "qualifiedname" : "dart.async._callbacksAreEnqueued"
    "comment" : ""
    "final" : "false"
    "static" : "false"
    "type" : "dart.core.bool"
  "_stackTraceExpando" : 
    "name" : "_stackTraceExpando"
    "qualifiedname" : "dart.async._stackTraceExpando"
    "comment" : ""
    "final" : "true"
    "static" : "false"
    "type" : "dart.core.Expando"
"functions" : 
  "runZonedExperimental" : 
    "name" : "runZonedExperimental"
    "qualifiedname" : "dart.async.runZonedExperimental"
    "comment" : "<p>Runs <code>body</code> in its own zone.</p> <p>If <code>onError</code> is non-null the zone is considered an error zone. All uncaught errors, synchronous or asynchronous, in the zone are caught and handled by the callback.</p> <p>The <code>onDone</code> handler (if non-null) is invoked when the zone has no more outstanding callbacks.</p> <p>The <code>onRunAsync</code> handler (if non-null) is invoked when the <code>body</code> executes <code>runAsync</code>.  The handler is invoked in the outer zone and can therefore execute <code>runAsync</code> without recursing. The given callback must be executed eventually. Otherwise the nested zone will not complete. It must be executed only once.</p> <p>Examples:</p> <pre><code>runZonedExperimental(() {   new Future(() { throw \"asynchronous error\"; }); }, onError: print);  // Will print \"asynchronous error\". </code></pre> <p>The following example prints \"1\", \"2\", \"3\", \"4\" in this order.</p> <pre><code>runZonedExperimental(() {   print(1);   new Future.value(3).then(print); }, onDone: () { print(4); }); print(2); </code></pre> <p>Errors may never cross error-zone boundaries. This is intuitive for leaving a zone, but it also applies for errors that would enter an error-zone. Errors that try to cross error-zone boundaries are considered uncaught.</p> <pre><code>var future = new Future.value(499); runZonedExperimental(() {   future = future.then((_) { throw \"error in first error-zone\"; });   runZonedExperimental(() {     future = future.catchError((e) { print(\"Never reached!\"); });   }, onError: (e) { print(\"unused error handler\"); }); }, onError: (e) { print(\"catches error of first error-zone.\"); }); </code></pre> <p>The following example prints the stack trace whenever a callback is registered using <code>runAsync</code> (which is also used by <code>Completer</code>s and <code>StreamController</code>s.</p> <pre><code>printStackTrace() { try { throw 0; } catch(e, s) { print(s); } } runZonedExperimental(body, onRunAsync: (callback) {   printStackTrace();   runAsync(callback); }); </code></pre>"
    "type" : "method"
    "static" : "false"
    "return" : "dynamic"
    "parameters" : 
      "body" : 
        "name" : "body"
        "qualifiedname" : "dart.async.runZonedExperimental#body"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.core.Function"
        "value" : "null"
      "onRunAsync" : 
        "name" : "onRunAsync"
        "qualifiedname" : "dart.async.runZonedExperimental#onRunAsync"
        "optional" : "true"
        "named" : "true"
        "default" : "false"
        "type" : "dart.core.Function"
        "value" : "null"
      "onError" : 
        "name" : "onError"
        "qualifiedname" : "dart.async.runZonedExperimental#onError"
        "optional" : "true"
        "named" : "true"
        "default" : "false"
        "type" : "dart.core.Function"
        "value" : "null"
      "onDone" : 
        "name" : "onDone"
        "qualifiedname" : "dart.async.runZonedExperimental#onDone"
        "optional" : "true"
        "named" : "true"
        "default" : "false"
        "type" : "dart.core.Function"
        "value" : "null"
  "_createPeriodicTimer" : 
    "name" : "_createPeriodicTimer"
    "qualifiedname" : "dart.async._createPeriodicTimer"
    "comment" : ""
    "type" : "method"
    "static" : "false"
    "return" : "dart.async.Timer"
    "parameters" : 
      "duration" : 
        "name" : "duration"
        "qualifiedname" : "dart.async._createPeriodicTimer#duration"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.core.Duration"
        "value" : "null"
      "callback" : 
        "name" : "callback"
        "qualifiedname" : "dart.async._createPeriodicTimer#callback"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.core.Function"
        "value" : "null"
  "_createTimer" : 
    "name" : "_createTimer"
    "qualifiedname" : "dart.async._createTimer"
    "comment" : ""
    "type" : "method"
    "static" : "false"
    "return" : "dart.async.Timer"
    "parameters" : 
      "duration" : 
        "name" : "duration"
        "qualifiedname" : "dart.async._createTimer#duration"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.core.Duration"
        "value" : "null"
      "callback" : 
        "name" : "callback"
        "qualifiedname" : "dart.async._createTimer#callback"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.core.Function"
        "value" : "null"
  "_defaultHandleDone" : 
    "name" : "_defaultHandleDone"
    "qualifiedname" : "dart.async._defaultHandleDone"
    "comment" : "<p>Default done handler forwards done.</p>"
    "type" : "method"
    "static" : "false"
    "return" : "void"
    "parameters" : 
      "sink" : 
        "name" : "sink"
        "qualifiedname" : "dart.async._defaultHandleDone#sink"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.async.EventSink"
        "value" : "null"
  "_defaultHandleError" : 
    "name" : "_defaultHandleError"
    "qualifiedname" : "dart.async._defaultHandleError"
    "comment" : "<p>Default error handler forwards all errors.</p>"
    "type" : "method"
    "static" : "false"
    "return" : "void"
    "parameters" : 
      "error" : 
        "name" : "error"
        "qualifiedname" : "dart.async._defaultHandleError#error"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dynamic"
        "value" : "null"
      "sink" : 
        "name" : "sink"
        "qualifiedname" : "dart.async._defaultHandleError#sink"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.async.EventSink"
        "value" : "null"
  "_defaultHandleData" : 
    "name" : "_defaultHandleData"
    "qualifiedname" : "dart.async._defaultHandleData"
    "comment" : "<p>Default data handler forwards all data.</p>"
    "type" : "method"
    "static" : "false"
    "return" : "void"
    "parameters" : 
      "data" : 
        "name" : "data"
        "qualifiedname" : "dart.async._defaultHandleData#data"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dynamic"
        "value" : "null"
      "sink" : 
        "name" : "sink"
        "qualifiedname" : "dart.async._defaultHandleData#sink"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.async.EventSink"
        "value" : "null"
  "_cancelAndError" : 
    "name" : "_cancelAndError"
    "qualifiedname" : "dart.async._cancelAndError"
    "comment" : "<p>Helper function to make an onError argument to <code>_runUserCode</code>.</p>"
    "type" : "method"
    "static" : "false"
    "return" : "dynamic"
    "parameters" : 
      "subscription" : 
        "name" : "subscription"
        "qualifiedname" : "dart.async._cancelAndError#subscription"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.async.StreamSubscription"
        "value" : "null"
      "future" : 
        "name" : "future"
        "qualifiedname" : "dart.async._cancelAndError#future"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.async._FutureImpl"
        "value" : "null"
  "_runUserCode" : 
    "name" : "_runUserCode"
    "qualifiedname" : "dart.async._runUserCode"
    "comment" : "<p>Runs user code and takes actions depending on success or failure.</p>"
    "type" : "method"
    "static" : "false"
    "return" : "dynamic"
    "parameters" : 
      "userCode" : 
        "name" : "userCode"
        "qualifiedname" : "dart.async._runUserCode#userCode"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.core.Function"
        "value" : "null"
      "onSuccess" : 
        "name" : "onSuccess"
        "qualifiedname" : "dart.async._runUserCode#onSuccess"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.core.Function"
        "value" : "null"
      "onError" : 
        "name" : "onError"
        "qualifiedname" : "dart.async._runUserCode#onError"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.core.Function"
        "value" : "null"
  "_asyncError" : 
    "name" : "_asyncError"
    "qualifiedname" : "dart.async._asyncError"
    "comment" : "<p>Utility function to attach a stack trace to an <code>error</code>  if it doesn't have one already.</p>"
    "type" : "method"
    "static" : "false"
    "return" : "dynamic"
    "parameters" : 
      "error" : 
        "name" : "error"
        "qualifiedname" : "dart.async._asyncError#error"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.core.Object"
        "value" : "null"
      "stackTrace" : 
        "name" : "stackTrace"
        "qualifiedname" : "dart.async._asyncError#stackTrace"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.core.Object"
        "value" : "null"
  "_nullDoneHandler" : 
    "name" : "_nullDoneHandler"
    "qualifiedname" : "dart.async._nullDoneHandler"
    "comment" : "<p>Default done handler, does nothing.</p>"
    "type" : "method"
    "static" : "false"
    "return" : "void"
    "parameters" : 
  "_nullErrorHandler" : 
    "name" : "_nullErrorHandler"
    "qualifiedname" : "dart.async._nullErrorHandler"
    "comment" : "<p>Default error handler, reports the error to the global handler.</p>"
    "type" : "method"
    "static" : "false"
    "return" : "void"
    "parameters" : 
      "error" : 
        "name" : "error"
        "qualifiedname" : "dart.async._nullErrorHandler#error"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dynamic"
        "value" : "null"
  "_nullDataHandler" : 
    "name" : "_nullDataHandler"
    "qualifiedname" : "dart.async._nullDataHandler"
    "comment" : "<p>Default data handler, does nothing.</p>"
    "type" : "method"
    "static" : "false"
    "return" : "void"
    "parameters" : 
      "value" : 
        "name" : "value"
        "qualifiedname" : "dart.async._nullDataHandler#value"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dynamic"
        "value" : "null"
  "_runGuarded" : 
    "name" : "_runGuarded"
    "qualifiedname" : "dart.async._runGuarded"
    "comment" : ""
    "type" : "method"
    "static" : "false"
    "return" : "void"
    "parameters" : 
      "notificationHandler" : 
        "name" : "notificationHandler"
        "qualifiedname" : "dart.async._runGuarded#notificationHandler"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.async._NotificationHandler"
        "value" : "null"
  "deprecatedFutureValue" : 
    "name" : "deprecatedFutureValue"
    "qualifiedname" : "dart.async.deprecatedFutureValue"
    "comment" : ""
    "type" : "method"
    "static" : "false"
    "return" : "dynamic"
    "parameters" : 
      "future" : 
        "name" : "future"
        "qualifiedname" : "dart.async.deprecatedFutureValue#future"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.async._FutureImpl"
        "value" : "null"
  "runAsync" : 
    "name" : "runAsync"
    "qualifiedname" : "dart.async.runAsync"
    "comment" : "<p>Runs the given <code>callback</code> asynchronously.</p> <p>Callbacks registered through this function are always executed in order and are guaranteed to run before other asynchronous events (like <code>Timer</code> events, or DOM events).</p> <p>Warning: it is possible to starve the DOM by registering asynchronous callbacks through this method. For example the following program will run the callbacks without ever giving the Timer callback a chance to execute:</p> <pre><code>Timer.run(() { print(\"executed\"); });  // Will never be executed; foo() {   asyncRun(foo);  // Schedules [foo] in front of other events. } main() {   foo(); } </code></pre>"
    "type" : "method"
    "static" : "false"
    "return" : "void"
    "parameters" : 
      "callback" : 
        "name" : "callback"
        "qualifiedname" : "dart.async.runAsync#callback"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dart.core.Function"
        "value" : "null"
  "_scheduleAsyncCallback" : 
    "name" : "_scheduleAsyncCallback"
    "qualifiedname" : "dart.async._scheduleAsyncCallback"
    "comment" : ""
    "type" : "method"
    "static" : "false"
    "return" : "void"
    "parameters" : 
      "callback" : 
        "name" : "callback"
        "qualifiedname" : "dart.async._scheduleAsyncCallback#callback"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dynamic"
        "value" : "null"
  "_asyncRunCallback" : 
    "name" : "_asyncRunCallback"
    "qualifiedname" : "dart.async._asyncRunCallback"
    "comment" : ""
    "type" : "method"
    "static" : "false"
    "return" : "void"
    "parameters" : 
  "getAttachedStackTrace" : 
    "name" : "getAttachedStackTrace"
    "qualifiedname" : "dart.async.getAttachedStackTrace"
    "comment" : "<p><em>This is an experimental API.</em></p> <p>Get the <code>StackTrace</code> attached to <code>o</code>.</p> <p>If object <code>o</code> was thrown and caught in a dart:async method, a <code>StackTrace</code> object was attached to it. Use <code>getAttachedStackTrace</code> to get that object.</p> <p>Returns <code>null</code> if no <code>StackTrace</code> was attached.</p>"
    "type" : "method"
    "static" : "false"
    "return" : "dynamic"
    "parameters" : 
      "o" : 
        "name" : "o"
        "qualifiedname" : "dart.async.getAttachedStackTrace#o"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dynamic"
        "value" : "null"
  "_attachStackTrace" : 
    "name" : "_attachStackTrace"
    "qualifiedname" : "dart.async._attachStackTrace"
    "comment" : ""
    "type" : "method"
    "static" : "false"
    "return" : "void"
    "parameters" : 
      "o" : 
        "name" : "o"
        "qualifiedname" : "dart.async._attachStackTrace#o"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dynamic"
        "value" : "null"
      "st" : 
        "name" : "st"
        "qualifiedname" : "dart.async._attachStackTrace#st"
        "optional" : "false"
        "named" : "false"
        "default" : "false"
        "type" : "dynamic"
        "value" : "null"
"classes" : 
  "_PeriodicZoneTimer" : 
    "name" : "_PeriodicZoneTimer"
    "qualifiedname" : "dart.async._PeriodicZoneTimer"
    "comment" : "<p>A <code>Timer</code> class for periodic callbacks that takes zones into account.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
      - "dart.async.Timer"
    "variables" : 
      "_zone" : 
        "name" : "_zone"
        "qualifiedname" : "dart.async._PeriodicZoneTimer._zone"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._Zone"
      "_callback" : 
        "name" : "_callback"
        "qualifiedname" : "dart.async._PeriodicZoneTimer._callback"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._PeriodicTimerCallback"
      "_timer" : 
        "name" : "_timer"
        "qualifiedname" : "dart.async._PeriodicZoneTimer._timer"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async.Timer"
      "_isDone" : 
        "name" : "_isDone"
        "qualifiedname" : "dart.async._PeriodicZoneTimer._isDone"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.bool"
    "methods" : 
      "_PeriodicZoneTimer" : 
        "name" : "_PeriodicZoneTimer"
        "qualifiedname" : "dart.async._PeriodicZoneTimer._PeriodicZoneTimer"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_zone" : 
            "name" : "_zone"
            "qualifiedname" : "dart.async._PeriodicZoneTimer._PeriodicZoneTimer#_zone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
          "duration" : 
            "name" : "duration"
            "qualifiedname" : "dart.async._PeriodicZoneTimer._PeriodicZoneTimer#duration"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Duration"
            "value" : "null"
          "_callback" : 
            "name" : "_callback"
            "qualifiedname" : "dart.async._PeriodicZoneTimer._PeriodicZoneTimer#_callback"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._PeriodicTimerCallback"
            "value" : "null"
      "_run" : 
        "name" : "_run"
        "qualifiedname" : "dart.async._PeriodicZoneTimer._run"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "timer" : 
            "name" : "timer"
            "qualifiedname" : "dart.async._PeriodicZoneTimer._run#timer"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Timer"
            "value" : "null"
      "cancel" : 
        "name" : "cancel"
        "qualifiedname" : "dart.async._PeriodicZoneTimer.cancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_PeriodicTimerCallback" : 
    "name" : "_PeriodicTimerCallback"
    "qualifiedname" : "dart.async._PeriodicTimerCallback"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_ZoneTimer" : 
    "name" : "_ZoneTimer"
    "qualifiedname" : "dart.async._ZoneTimer"
    "comment" : "<p>A <code>Timer</code> class that takes zones into account.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
      - "dart.async.Timer"
    "variables" : 
      "_zone" : 
        "name" : "_zone"
        "qualifiedname" : "dart.async._ZoneTimer._zone"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._Zone"
      "_callback" : 
        "name" : "_callback"
        "qualifiedname" : "dart.async._ZoneTimer._callback"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._TimerCallback"
      "_timer" : 
        "name" : "_timer"
        "qualifiedname" : "dart.async._ZoneTimer._timer"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async.Timer"
      "_isDone" : 
        "name" : "_isDone"
        "qualifiedname" : "dart.async._ZoneTimer._isDone"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.bool"
    "methods" : 
      "_ZoneTimer" : 
        "name" : "_ZoneTimer"
        "qualifiedname" : "dart.async._ZoneTimer._ZoneTimer"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_zone" : 
            "name" : "_zone"
            "qualifiedname" : "dart.async._ZoneTimer._ZoneTimer#_zone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
          "duration" : 
            "name" : "duration"
            "qualifiedname" : "dart.async._ZoneTimer._ZoneTimer#duration"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Duration"
            "value" : "null"
          "_callback" : 
            "name" : "_callback"
            "qualifiedname" : "dart.async._ZoneTimer._ZoneTimer#_callback"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._TimerCallback"
            "value" : "null"
      "_run" : 
        "name" : "_run"
        "qualifiedname" : "dart.async._ZoneTimer._run"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "cancel" : 
        "name" : "cancel"
        "qualifiedname" : "dart.async._ZoneTimer.cancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_TimerCallback" : 
    "name" : "_TimerCallback"
    "qualifiedname" : "dart.async._TimerCallback"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_RunAsyncZone" : 
    "name" : "_RunAsyncZone"
    "qualifiedname" : "dart.async._RunAsyncZone"
    "comment" : ""
    "superclass" : "dart.async._ZoneBase"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_runAsyncInterceptor" : 
        "name" : "_runAsyncInterceptor"
        "qualifiedname" : "dart.async._RunAsyncZone._runAsyncInterceptor"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._RunAsyncInterceptor"
    "methods" : 
      "_RunAsyncZone" : 
        "name" : "_RunAsyncZone"
        "qualifiedname" : "dart.async._RunAsyncZone._RunAsyncZone"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "parentZone" : 
            "name" : "parentZone"
            "qualifiedname" : "dart.async._RunAsyncZone._RunAsyncZone#parentZone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
          "_runAsyncInterceptor" : 
            "name" : "_runAsyncInterceptor"
            "qualifiedname" : "dart.async._RunAsyncZone._RunAsyncZone#_runAsyncInterceptor"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._RunAsyncInterceptor"
            "value" : "null"
      "runAsync" : 
        "name" : "runAsync"
        "qualifiedname" : "dart.async._RunAsyncZone.runAsync"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "callback" : 
            "name" : "callback"
            "qualifiedname" : "dart.async._RunAsyncZone.runAsync#callback"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "zone" : 
            "name" : "zone"
            "qualifiedname" : "dart.async._RunAsyncZone.runAsync#zone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
  "_RunAsyncInterceptor" : 
    "name" : "_RunAsyncInterceptor"
    "qualifiedname" : "dart.async._RunAsyncInterceptor"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_CatchErrorsZone" : 
    "name" : "_CatchErrorsZone"
    "qualifiedname" : "dart.async._CatchErrorsZone"
    "comment" : "<p>A zone that collects all uncaught errors and provides them in a stream. The stream is closed when the zone is done.</p>"
    "superclass" : "dart.async._WaitForCompletionZone"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_handleError" : 
        "name" : "_handleError"
        "qualifiedname" : "dart.async._CatchErrorsZone._handleError"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._HandleErrorCallback"
    "methods" : 
      "_CatchErrorsZone" : 
        "name" : "_CatchErrorsZone"
        "qualifiedname" : "dart.async._CatchErrorsZone._CatchErrorsZone"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "parentZone" : 
            "name" : "parentZone"
            "qualifiedname" : "dart.async._CatchErrorsZone._CatchErrorsZone#parentZone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
          "_handleError" : 
            "name" : "_handleError"
            "qualifiedname" : "dart.async._CatchErrorsZone._CatchErrorsZone#_handleError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._HandleErrorCallback"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async._CatchErrorsZone._CatchErrorsZone#onDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_errorZone" : 
        "name" : "_errorZone"
        "qualifiedname" : "dart.async._CatchErrorsZone._errorZone"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async._Zone"
        "parameters" : 
      "handleUncaughtError" : 
        "name" : "handleUncaughtError"
        "qualifiedname" : "dart.async._CatchErrorsZone.handleUncaughtError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._CatchErrorsZone.handleUncaughtError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "runWaitForCompletion" : 
        "name" : "runWaitForCompletion"
        "qualifiedname" : "dart.async._CatchErrorsZone.runWaitForCompletion"
        "comment" : "<p>Runs the given function asynchronously. Executes the <code>_onDone</code> callback when the zone is done.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._CatchErrorsZone.runWaitForCompletion#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "toString" : 
        "name" : "toString"
        "qualifiedname" : "dart.async._CatchErrorsZone.toString"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.core.String"
        "parameters" : 
  "_HandleErrorCallback" : 
    "name" : "_HandleErrorCallback"
    "qualifiedname" : "dart.async._HandleErrorCallback"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_WaitForCompletionZone" : 
    "name" : "_WaitForCompletionZone"
    "qualifiedname" : "dart.async._WaitForCompletionZone"
    "comment" : "<p>A zone that executes a callback when the zone is dead.</p>"
    "superclass" : "dart.async._ZoneBase"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_onDone" : 
        "name" : "_onDone"
        "qualifiedname" : "dart.async._WaitForCompletionZone._onDone"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._CompletionCallback"
    "methods" : 
      "_WaitForCompletionZone" : 
        "name" : "_WaitForCompletionZone"
        "qualifiedname" : "dart.async._WaitForCompletionZone._WaitForCompletionZone"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "parentZone" : 
            "name" : "parentZone"
            "qualifiedname" : "dart.async._WaitForCompletionZone._WaitForCompletionZone#parentZone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
          "_onDone" : 
            "name" : "_onDone"
            "qualifiedname" : "dart.async._WaitForCompletionZone._WaitForCompletionZone#_onDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._CompletionCallback"
            "value" : "null"
      "runWaitForCompletion" : 
        "name" : "runWaitForCompletion"
        "qualifiedname" : "dart.async._WaitForCompletionZone.runWaitForCompletion"
        "comment" : "<p>Runs the given function asynchronously. Executes the <code>_onDone</code> callback when the zone is done.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._WaitForCompletionZone.runWaitForCompletion#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_dispose" : 
        "name" : "_dispose"
        "qualifiedname" : "dart.async._WaitForCompletionZone._dispose"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
      "toString" : 
        "name" : "toString"
        "qualifiedname" : "dart.async._WaitForCompletionZone.toString"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.core.String"
        "parameters" : 
  "_CompletionCallback" : 
    "name" : "_CompletionCallback"
    "qualifiedname" : "dart.async._CompletionCallback"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_DefaultZone" : 
    "name" : "_DefaultZone"
    "qualifiedname" : "dart.async._DefaultZone"
    "comment" : "<p>The default-zone that conceptually surrounds the <code>main</code> function.</p>"
    "superclass" : "dart.async._ZoneBase"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "_DefaultZone" : 
        "name" : "_DefaultZone"
        "qualifiedname" : "dart.async._DefaultZone._DefaultZone"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
      "_errorZone" : 
        "name" : "_errorZone"
        "qualifiedname" : "dart.async._DefaultZone._errorZone"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async._Zone"
        "parameters" : 
      "handleUncaughtError" : 
        "name" : "handleUncaughtError"
        "qualifiedname" : "dart.async._DefaultZone.handleUncaughtError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._DefaultZone.handleUncaughtError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "runAsync" : 
        "name" : "runAsync"
        "qualifiedname" : "dart.async._DefaultZone.runAsync"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._DefaultZone.runAsync#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "zone" : 
            "name" : "zone"
            "qualifiedname" : "dart.async._DefaultZone.runAsync#zone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
  "_ZoneBase" : 
    "name" : "_ZoneBase"
    "qualifiedname" : "dart.async._ZoneBase"
    "comment" : "<p>Basic implementation of a <code>_Zone</code>. This class is intended for subclassing.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
      - "dart.async._Zone"
    "variables" : 
      "_parentZone" : 
        "name" : "_parentZone"
        "qualifiedname" : "dart.async._ZoneBase._parentZone"
        "comment" : "<p>The parent zone. <code>null</code> if <code>this</code> is the default zone.</p>"
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._Zone"
      "_children" : 
        "name" : "_children"
        "qualifiedname" : "dart.async._ZoneBase._children"
        "comment" : "<p>The children of this zone. A child's <code>_parentZone</code> is <code>this</code>.</p>"
        "final" : "true"
        "static" : "false"
        "type" : "dart.core.List"
      "_openCallbacks" : 
        "name" : "_openCallbacks"
        "qualifiedname" : "dart.async._ZoneBase._openCallbacks"
        "comment" : "<p>The number of outstanding (asynchronous) callbacks. As long as the number is greater than 0 it means that the zone is not done yet.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.int"
      "_isExecutingCallback" : 
        "name" : "_isExecutingCallback"
        "qualifiedname" : "dart.async._ZoneBase._isExecutingCallback"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.bool"
    "methods" : 
      "_ZoneBase" : 
        "name" : "_ZoneBase"
        "qualifiedname" : "dart.async._ZoneBase._ZoneBase"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_parentZone" : 
            "name" : "_parentZone"
            "qualifiedname" : "dart.async._ZoneBase._ZoneBase#_parentZone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
      "_ZoneBase._defaultZone" : 
        "name" : "_ZoneBase._defaultZone"
        "qualifiedname" : "dart.async._ZoneBase._ZoneBase._defaultZone"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
      "_errorZone" : 
        "name" : "_errorZone"
        "qualifiedname" : "dart.async._ZoneBase._errorZone"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async._Zone"
        "parameters" : 
      "handleUncaughtError" : 
        "name" : "handleUncaughtError"
        "qualifiedname" : "dart.async._ZoneBase.handleUncaughtError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._ZoneBase.handleUncaughtError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "inSameErrorZone" : 
        "name" : "inSameErrorZone"
        "qualifiedname" : "dart.async._ZoneBase.inSameErrorZone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
          "otherZone" : 
            "name" : "otherZone"
            "qualifiedname" : "dart.async._ZoneBase.inSameErrorZone#otherZone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
      "fork" : 
        "name" : "fork"
        "qualifiedname" : "dart.async._ZoneBase.fork"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async._Zone"
        "parameters" : 
      "expectCallback" : 
        "name" : "expectCallback"
        "qualifiedname" : "dart.async._ZoneBase.expectCallback"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
      "cancelCallbackExpectation" : 
        "name" : "cancelCallbackExpectation"
        "qualifiedname" : "dart.async._ZoneBase.cancelCallbackExpectation"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
      "_dispose" : 
        "name" : "_dispose"
        "qualifiedname" : "dart.async._ZoneBase._dispose"
        "comment" : "<p>Cleans up this zone when it is done.</p> <p>This releases internal memore structures that are no longer necessary.</p> <p>A zone is done when its dynamic extent has finished executing and there are no outstanding asynchronous callbacks.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
      "_checkIfDone" : 
        "name" : "_checkIfDone"
        "qualifiedname" : "dart.async._ZoneBase._checkIfDone"
        "comment" : "<p>Checks if the zone is done and doesn't have any outstanding callbacks anymore.</p> <p>This method is called when an operation has decremented the outstanding-callback count, or when a child has been removed.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "executeCallback" : 
        "name" : "executeCallback"
        "qualifiedname" : "dart.async._ZoneBase.executeCallback"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._ZoneBase.executeCallback#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "executeCallbackGuarded" : 
        "name" : "executeCallbackGuarded"
        "qualifiedname" : "dart.async._ZoneBase.executeCallbackGuarded"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._ZoneBase.executeCallbackGuarded#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "executePeriodicCallback" : 
        "name" : "executePeriodicCallback"
        "qualifiedname" : "dart.async._ZoneBase.executePeriodicCallback"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._ZoneBase.executePeriodicCallback#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "executePeriodicCallbackGuarded" : 
        "name" : "executePeriodicCallbackGuarded"
        "qualifiedname" : "dart.async._ZoneBase.executePeriodicCallbackGuarded"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._ZoneBase.executePeriodicCallbackGuarded#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "runFromChildZone" : 
        "name" : "runFromChildZone"
        "qualifiedname" : "dart.async._ZoneBase.runFromChildZone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._ZoneBase.runFromChildZone#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "runFromChildZoneGuarded" : 
        "name" : "runFromChildZoneGuarded"
        "qualifiedname" : "dart.async._ZoneBase.runFromChildZoneGuarded"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._ZoneBase.runFromChildZoneGuarded#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_runInZone" : 
        "name" : "_runInZone"
        "qualifiedname" : "dart.async._ZoneBase._runInZone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._ZoneBase._runInZone#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "handleUncaught" : 
            "name" : "handleUncaught"
            "qualifiedname" : "dart.async._ZoneBase._runInZone#handleUncaught"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
      "_runGuarded" : 
        "name" : "_runGuarded"
        "qualifiedname" : "dart.async._ZoneBase._runGuarded"
        "comment" : "<p>Runs the function and catches uncaught errors.</p> <p>Uncaught errors are given to <code>handleUncaughtError</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._ZoneBase._runGuarded#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_runUnguarded" : 
        "name" : "_runUnguarded"
        "qualifiedname" : "dart.async._ZoneBase._runUnguarded"
        "comment" : "<p>Runs the function but doesn't catch uncaught errors.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._ZoneBase._runUnguarded#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "runAsync" : 
        "name" : "runAsync"
        "qualifiedname" : "dart.async._ZoneBase.runAsync"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._ZoneBase.runAsync#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "zone" : 
            "name" : "zone"
            "qualifiedname" : "dart.async._ZoneBase.runAsync#zone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
      "createTimer" : 
        "name" : "createTimer"
        "qualifiedname" : "dart.async._ZoneBase.createTimer"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Timer"
        "parameters" : 
          "duration" : 
            "name" : "duration"
            "qualifiedname" : "dart.async._ZoneBase.createTimer#duration"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Duration"
            "value" : "null"
          "callback" : 
            "name" : "callback"
            "qualifiedname" : "dart.async._ZoneBase.createTimer#callback"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "createPeriodicTimer" : 
        "name" : "createPeriodicTimer"
        "qualifiedname" : "dart.async._ZoneBase.createPeriodicTimer"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Timer"
        "parameters" : 
          "duration" : 
            "name" : "duration"
            "qualifiedname" : "dart.async._ZoneBase.createPeriodicTimer#duration"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Duration"
            "value" : "null"
          "callback" : 
            "name" : "callback"
            "qualifiedname" : "dart.async._ZoneBase.createPeriodicTimer#callback"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_addChild" : 
        "name" : "_addChild"
        "qualifiedname" : "dart.async._ZoneBase._addChild"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "child" : 
            "name" : "child"
            "qualifiedname" : "dart.async._ZoneBase._addChild#child"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
      "_removeChild" : 
        "name" : "_removeChild"
        "qualifiedname" : "dart.async._ZoneBase._removeChild"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "child" : 
            "name" : "child"
            "qualifiedname" : "dart.async._ZoneBase._removeChild#child"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
  "_Zone" : 
    "name" : "_Zone"
    "qualifiedname" : "dart.async._Zone"
    "comment" : "<p>A Zone represents the asynchronous version of a dynamic extent. Asynchronous callbacks are executed in the zone they have been queued in. For example, the callback of a <code>future.then</code> is executed in the same zone as the one where the <code>then</code> was invoked.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_current" : 
        "name" : "_current"
        "qualifiedname" : "dart.async._Zone._current"
        "comment" : "<p>The currently running zone.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.async._Zone"
    "methods" : 
      "current" : 
        "name" : "current"
        "qualifiedname" : "dart.async._Zone.current"
        "comment" : ""
        "type" : "getter"
        "static" : "true"
        "return" : "dart.async._Zone"
        "parameters" : 
      "handleUncaughtError" : 
        "name" : "handleUncaughtError"
        "qualifiedname" : "dart.async._Zone.handleUncaughtError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._Zone.handleUncaughtError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "inSameErrorZone" : 
        "name" : "inSameErrorZone"
        "qualifiedname" : "dart.async._Zone.inSameErrorZone"
        "comment" : "<p>Returns true if <code>this</code> and <code>otherZone</code> are in the same error zone.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
          "otherZone" : 
            "name" : "otherZone"
            "qualifiedname" : "dart.async._Zone.inSameErrorZone#otherZone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
      "fork" : 
        "name" : "fork"
        "qualifiedname" : "dart.async._Zone.fork"
        "comment" : "<p>Returns a zone for reentry in the zone.</p> <p>The returned zone is equivalent to <code>this</code> (and frequently is indeed <code>this</code>).</p> <p>The main purpose of this method is to allow <code>this</code> to attach debugging information to the returned zone.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async._Zone"
        "parameters" : 
      "expectCallback" : 
        "name" : "expectCallback"
        "qualifiedname" : "dart.async._Zone.expectCallback"
        "comment" : "<p>Tells the zone that it needs to wait for one more callback before it is done.</p> <p>Use <code>executeCallback</code> or <code>cancelCallbackExpectation</code> when the callback is executed (or canceled).</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "cancelCallbackExpectation" : 
        "name" : "cancelCallbackExpectation"
        "qualifiedname" : "dart.async._Zone.cancelCallbackExpectation"
        "comment" : "<p>Tells the zone not to wait for a callback anymore.</p> <p>Prefer calling <code>executeCallback</code>, instead. This method is mostly useful for repeated callbacks (for example with <code>Timer.periodic</code>). In this case one should should call <code>expectCallback</code> when the repeated callback is initiated, and <code>cancelCallbackExpectation</code> when the <code>Timer</code> is canceled.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "executeCallback" : 
        "name" : "executeCallback"
        "qualifiedname" : "dart.async._Zone.executeCallback"
        "comment" : "<p>Executes the given callback <code>f</code> in this zone.</p> <p>Decrements the number of callbacks this zone is waiting for (see <code>expectCallback</code>).</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._Zone.executeCallback#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "executeCallbackGuarded" : 
        "name" : "executeCallbackGuarded"
        "qualifiedname" : "dart.async._Zone.executeCallbackGuarded"
        "comment" : "<p>Same as <code>executeCallback</code> but catches uncaught errors and gives them to <code>handleUncaughtError</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._Zone.executeCallbackGuarded#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "executePeriodicCallback" : 
        "name" : "executePeriodicCallback"
        "qualifiedname" : "dart.async._Zone.executePeriodicCallback"
        "comment" : "<p>Same as <code>executeCallback</code> but does not decrement the number of callbacks this zone is waiting for (see <code>expectCallback</code>).</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._Zone.executePeriodicCallback#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "executePeriodicCallbackGuarded" : 
        "name" : "executePeriodicCallbackGuarded"
        "qualifiedname" : "dart.async._Zone.executePeriodicCallbackGuarded"
        "comment" : "<p>Same as <code>executePeriodicCallback</code> but catches uncaught errors and gives them to <code>handleUncaughtError</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._Zone.executePeriodicCallbackGuarded#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "runFromChildZone" : 
        "name" : "runFromChildZone"
        "qualifiedname" : "dart.async._Zone.runFromChildZone"
        "comment" : "<p>Executes <code>f</code> in <code>this</code> zone.</p> <p>The behavior of this method should be the same as <code>executePeriodicCallback</code> except that it can have a return value.</p> <p>Returns the result of the invocation.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._Zone.runFromChildZone#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "runFromChildZoneGuarded" : 
        "name" : "runFromChildZoneGuarded"
        "qualifiedname" : "dart.async._Zone.runFromChildZoneGuarded"
        "comment" : "<p>Same as <code>runFromChildZone</code> but catches uncaught errors and gives them to <code>handleUncaughtError</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._Zone.runFromChildZoneGuarded#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "runAsync" : 
        "name" : "runAsync"
        "qualifiedname" : "dart.async._Zone.runAsync"
        "comment" : "<p>Runs <code>f</code> asynchronously in <code>zone</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._Zone.runAsync#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "zone" : 
            "name" : "zone"
            "qualifiedname" : "dart.async._Zone.runAsync#zone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
      "createTimer" : 
        "name" : "createTimer"
        "qualifiedname" : "dart.async._Zone.createTimer"
        "comment" : "<p>Creates a Timer where the callback is executed in this zone.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Timer"
        "parameters" : 
          "duration" : 
            "name" : "duration"
            "qualifiedname" : "dart.async._Zone.createTimer#duration"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Duration"
            "value" : "null"
          "callback" : 
            "name" : "callback"
            "qualifiedname" : "dart.async._Zone.createTimer#callback"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "createPeriodicTimer" : 
        "name" : "createPeriodicTimer"
        "qualifiedname" : "dart.async._Zone.createPeriodicTimer"
        "comment" : "<p>Creates a periodic Timer where the callback is executed in this zone.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Timer"
        "parameters" : 
          "duration" : 
            "name" : "duration"
            "qualifiedname" : "dart.async._Zone.createPeriodicTimer#duration"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Duration"
            "value" : "null"
          "callback" : 
            "name" : "callback"
            "qualifiedname" : "dart.async._Zone.createPeriodicTimer#callback"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_errorZone" : 
        "name" : "_errorZone"
        "qualifiedname" : "dart.async._Zone._errorZone"
        "comment" : "<p>The error zone is the one that is responsible for dealing with uncaught errors. Errors are not allowed to cross zones with different error-zones.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async._Zone"
        "parameters" : 
      "_addChild" : 
        "name" : "_addChild"
        "qualifiedname" : "dart.async._Zone._addChild"
        "comment" : "<p>Adds <code>child</code> as a child of <code>this</code>.</p> <p>This usually means that the <code>child</code> is in the asynchronous dynamic extent of <code>this</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "child" : 
            "name" : "child"
            "qualifiedname" : "dart.async._Zone._addChild#child"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
      "_removeChild" : 
        "name" : "_removeChild"
        "qualifiedname" : "dart.async._Zone._removeChild"
        "comment" : "<p>Removes <code>child</code> from <code>this</code>' children.</p> <p>This usually means that the <code>child</code> has finished executing and is done.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "child" : 
            "name" : "child"
            "qualifiedname" : "dart.async._Zone._removeChild#child"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
  "Timer" : 
    "name" : "Timer"
    "qualifiedname" : "dart.async.Timer"
    "comment" : ""
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "Timer" : 
        "name" : "Timer"
        "qualifiedname" : "dart.async.Timer.Timer"
        "comment" : "<p>Creates a new timer.</p> <p>The <code>callback</code> callback is invoked after the given <code>duration</code>. A negative duration is treated similar to a duration of 0.</p> <p>If the <code>duration</code> is statically known to be 0, consider using <code>run</code>.</p> <p>Frequently the <code>duration</code> is either a constant or computed as in the following example (taking advantage of the multiplication operator of the Duration class):</p> <pre><code>const TIMEOUT = const Duration(seconds: 3); const ms = const Duration(milliseconds: 1);  startTimeout([int milliseconds]) {   var duration = milliseconds == null ? TIMEOUT : ms * milliseconds;   return new Timer(duration, handleTimeout); } </code></pre> <p>Note: If Dart code using Timer is compiled to JavaScript, the finest granularity available in the browser is 4 milliseconds.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.Timer"
        "parameters" : 
          "duration" : 
            "name" : "duration"
            "qualifiedname" : "dart.async.Timer.Timer#duration"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Duration"
            "value" : "null"
          "callback" : 
            "name" : "callback"
            "qualifiedname" : "dart.async.Timer.Timer#callback"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "Timer.periodic" : 
        "name" : "Timer.periodic"
        "qualifiedname" : "dart.async.Timer.Timer.periodic"
        "comment" : "<p>Creates a new repeating timer.</p> <p>The <code>callback</code> is invoked repeatedly with <code>duration</code> intervals until canceled. A negative duration is treated similar to a duration of 0.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.Timer"
        "parameters" : 
          "duration" : 
            "name" : "duration"
            "qualifiedname" : "dart.async.Timer.Timer.periodic#duration"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Duration"
            "value" : "null"
          "callback" : 
            "name" : "callback"
            "qualifiedname" : "dart.async.Timer.Timer.periodic#callback"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "run" : 
        "name" : "run"
        "qualifiedname" : "dart.async.Timer.run"
        "comment" : "<p>Runs the given <code>callback</code> asynchronously as soon as possible.</p> <p>This function is equivalent to <code>new Timer(Duration.ZERO, callback)</code>.</p>"
        "type" : "method"
        "static" : "true"
        "return" : "void"
        "parameters" : 
          "callback" : 
            "name" : "callback"
            "qualifiedname" : "dart.async.Timer.run#callback"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "cancel" : 
        "name" : "cancel"
        "qualifiedname" : "dart.async.Timer.cancel"
        "comment" : "<p>Cancels the timer.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_StreamTransformerImpl" : 
    "name" : "_StreamTransformerImpl"
    "qualifiedname" : "dart.async._StreamTransformerImpl"
    "comment" : "<p>A <code>StreamTransformer</code> that modifies stream events.</p> <p>This class is used by <code>StreamTransformer</code>'s factory constructor. It is actually an <code>StreamEventTransformer</code> where the functions used to modify the events are passed as constructor arguments.</p> <p>If an argument is omitted, it acts as the default method from <code>StreamEventTransformer</code>.</p>"
    "superclass" : "dart.async.StreamEventTransformer"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_handleData" : 
        "name" : "_handleData"
        "qualifiedname" : "dart.async._StreamTransformerImpl._handleData"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.core.Function"
      "_handleError" : 
        "name" : "_handleError"
        "qualifiedname" : "dart.async._StreamTransformerImpl._handleError"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._TransformErrorHandler"
      "_handleDone" : 
        "name" : "_handleDone"
        "qualifiedname" : "dart.async._StreamTransformerImpl._handleDone"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._TransformDoneHandler"
    "methods" : 
      "_StreamTransformerImpl" : 
        "name" : "_StreamTransformerImpl"
        "qualifiedname" : "dart.async._StreamTransformerImpl._StreamTransformerImpl"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "handleData" : 
            "name" : "handleData"
            "qualifiedname" : "dart.async._StreamTransformerImpl._StreamTransformerImpl#handleData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "handleError" : 
            "name" : "handleError"
            "qualifiedname" : "dart.async._StreamTransformerImpl._StreamTransformerImpl#handleError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "handleDone" : 
            "name" : "handleDone"
            "qualifiedname" : "dart.async._StreamTransformerImpl._StreamTransformerImpl#handleDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "handleData" : 
        "name" : "handleData"
        "qualifiedname" : "dart.async._StreamTransformerImpl.handleData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._StreamTransformerImpl.handleData#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._StreamTransformerImpl.S"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._StreamTransformerImpl.handleData#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.EventSink"
            "value" : "null"
      "handleError" : 
        "name" : "handleError"
        "qualifiedname" : "dart.async._StreamTransformerImpl.handleError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._StreamTransformerImpl.handleError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._StreamTransformerImpl.handleError#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.EventSink"
            "value" : "null"
      "handleDone" : 
        "name" : "handleDone"
        "qualifiedname" : "dart.async._StreamTransformerImpl.handleDone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._StreamTransformerImpl.handleDone#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.EventSink"
            "value" : "null"
  "_TransformDoneHandler" : 
    "name" : "_TransformDoneHandler"
    "qualifiedname" : "dart.async._TransformDoneHandler"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_TransformErrorHandler" : 
    "name" : "_TransformErrorHandler"
    "qualifiedname" : "dart.async._TransformErrorHandler"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_TransformDataHandler" : 
    "name" : "_TransformDataHandler"
    "qualifiedname" : "dart.async._TransformDataHandler"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_DistinctStream" : 
    "name" : "_DistinctStream"
    "qualifiedname" : "dart.async._DistinctStream"
    "comment" : ""
    "superclass" : "dart.async._ForwardingStream"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_SENTINEL" : 
        "name" : "_SENTINEL"
        "qualifiedname" : "dart.async._DistinctStream._SENTINEL"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dynamic"
      "_equals" : 
        "name" : "_equals"
        "qualifiedname" : "dart.async._DistinctStream._equals"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._Equality"
      "_previous" : 
        "name" : "_previous"
        "qualifiedname" : "dart.async._DistinctStream._previous"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dynamic"
    "methods" : 
      "_DistinctStream" : 
        "name" : "_DistinctStream"
        "qualifiedname" : "dart.async._DistinctStream._DistinctStream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "source" : 
            "name" : "source"
            "qualifiedname" : "dart.async._DistinctStream._DistinctStream#source"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
          "equals" : 
            "name" : "equals"
            "qualifiedname" : "dart.async._DistinctStream._DistinctStream#equals"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_handleData" : 
        "name" : "_handleData"
        "qualifiedname" : "dart.async._DistinctStream._handleData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "inputEvent" : 
            "name" : "inputEvent"
            "qualifiedname" : "dart.async._DistinctStream._handleData#inputEvent"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._DistinctStream.T"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._DistinctStream._handleData#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSink"
            "value" : "null"
  "_Equality" : 
    "name" : "_Equality"
    "qualifiedname" : "dart.async._Equality"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_SkipWhileStream" : 
    "name" : "_SkipWhileStream"
    "qualifiedname" : "dart.async._SkipWhileStream"
    "comment" : ""
    "superclass" : "dart.async._ForwardingStream"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_test" : 
        "name" : "_test"
        "qualifiedname" : "dart.async._SkipWhileStream._test"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._Predicate"
      "_hasFailed" : 
        "name" : "_hasFailed"
        "qualifiedname" : "dart.async._SkipWhileStream._hasFailed"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.bool"
    "methods" : 
      "_SkipWhileStream" : 
        "name" : "_SkipWhileStream"
        "qualifiedname" : "dart.async._SkipWhileStream._SkipWhileStream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "source" : 
            "name" : "source"
            "qualifiedname" : "dart.async._SkipWhileStream._SkipWhileStream#source"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async._SkipWhileStream._SkipWhileStream#test"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_handleData" : 
        "name" : "_handleData"
        "qualifiedname" : "dart.async._SkipWhileStream._handleData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "inputEvent" : 
            "name" : "inputEvent"
            "qualifiedname" : "dart.async._SkipWhileStream._handleData#inputEvent"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._SkipWhileStream.T"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._SkipWhileStream._handleData#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSink"
            "value" : "null"
  "_SkipStream" : 
    "name" : "_SkipStream"
    "qualifiedname" : "dart.async._SkipStream"
    "comment" : ""
    "superclass" : "dart.async._ForwardingStream"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_remaining" : 
        "name" : "_remaining"
        "qualifiedname" : "dart.async._SkipStream._remaining"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.int"
    "methods" : 
      "_SkipStream" : 
        "name" : "_SkipStream"
        "qualifiedname" : "dart.async._SkipStream._SkipStream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "source" : 
            "name" : "source"
            "qualifiedname" : "dart.async._SkipStream._SkipStream#source"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
          "count" : 
            "name" : "count"
            "qualifiedname" : "dart.async._SkipStream._SkipStream#count"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.int"
            "value" : "null"
      "_handleData" : 
        "name" : "_handleData"
        "qualifiedname" : "dart.async._SkipStream._handleData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "inputEvent" : 
            "name" : "inputEvent"
            "qualifiedname" : "dart.async._SkipStream._handleData#inputEvent"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._SkipStream.T"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._SkipStream._handleData#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSink"
            "value" : "null"
  "_TakeWhileStream" : 
    "name" : "_TakeWhileStream"
    "qualifiedname" : "dart.async._TakeWhileStream"
    "comment" : ""
    "superclass" : "dart.async._ForwardingStream"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_test" : 
        "name" : "_test"
        "qualifiedname" : "dart.async._TakeWhileStream._test"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._Predicate"
    "methods" : 
      "_TakeWhileStream" : 
        "name" : "_TakeWhileStream"
        "qualifiedname" : "dart.async._TakeWhileStream._TakeWhileStream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "source" : 
            "name" : "source"
            "qualifiedname" : "dart.async._TakeWhileStream._TakeWhileStream#source"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async._TakeWhileStream._TakeWhileStream#test"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_handleData" : 
        "name" : "_handleData"
        "qualifiedname" : "dart.async._TakeWhileStream._handleData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "inputEvent" : 
            "name" : "inputEvent"
            "qualifiedname" : "dart.async._TakeWhileStream._handleData#inputEvent"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._TakeWhileStream.T"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._TakeWhileStream._handleData#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSink"
            "value" : "null"
  "_TakeStream" : 
    "name" : "_TakeStream"
    "qualifiedname" : "dart.async._TakeStream"
    "comment" : ""
    "superclass" : "dart.async._ForwardingStream"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_remaining" : 
        "name" : "_remaining"
        "qualifiedname" : "dart.async._TakeStream._remaining"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.int"
    "methods" : 
      "_TakeStream" : 
        "name" : "_TakeStream"
        "qualifiedname" : "dart.async._TakeStream._TakeStream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "source" : 
            "name" : "source"
            "qualifiedname" : "dart.async._TakeStream._TakeStream#source"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
          "count" : 
            "name" : "count"
            "qualifiedname" : "dart.async._TakeStream._TakeStream#count"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.int"
            "value" : "null"
      "_handleData" : 
        "name" : "_handleData"
        "qualifiedname" : "dart.async._TakeStream._handleData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "inputEvent" : 
            "name" : "inputEvent"
            "qualifiedname" : "dart.async._TakeStream._handleData#inputEvent"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._TakeStream.T"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._TakeStream._handleData#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSink"
            "value" : "null"
  "_HandleErrorStream" : 
    "name" : "_HandleErrorStream"
    "qualifiedname" : "dart.async._HandleErrorStream"
    "comment" : "<p>A stream pipe that converts or disposes error events before passing them on.</p>"
    "superclass" : "dart.async._ForwardingStream"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_transform" : 
        "name" : "_transform"
        "qualifiedname" : "dart.async._HandleErrorStream._transform"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._ErrorTransformation"
      "_test" : 
        "name" : "_test"
        "qualifiedname" : "dart.async._HandleErrorStream._test"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._ErrorTest"
    "methods" : 
      "_HandleErrorStream" : 
        "name" : "_HandleErrorStream"
        "qualifiedname" : "dart.async._HandleErrorStream._HandleErrorStream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "source" : 
            "name" : "source"
            "qualifiedname" : "dart.async._HandleErrorStream._HandleErrorStream#source"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
          "transform" : 
            "name" : "transform"
            "qualifiedname" : "dart.async._HandleErrorStream._HandleErrorStream#transform"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async._HandleErrorStream._HandleErrorStream#test"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_handleError" : 
        "name" : "_handleError"
        "qualifiedname" : "dart.async._HandleErrorStream._handleError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._HandleErrorStream._handleError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._HandleErrorStream._handleError#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSink"
            "value" : "null"
  "_ErrorTest" : 
    "name" : "_ErrorTest"
    "qualifiedname" : "dart.async._ErrorTest"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_ErrorTransformation" : 
    "name" : "_ErrorTransformation"
    "qualifiedname" : "dart.async._ErrorTransformation"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_ExpandStream" : 
    "name" : "_ExpandStream"
    "qualifiedname" : "dart.async._ExpandStream"
    "comment" : "<p>A stream pipe that converts data events before passing them on.</p>"
    "superclass" : "dart.async._ForwardingStream"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_expand" : 
        "name" : "_expand"
        "qualifiedname" : "dart.async._ExpandStream._expand"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._Transformation"
    "methods" : 
      "_ExpandStream" : 
        "name" : "_ExpandStream"
        "qualifiedname" : "dart.async._ExpandStream._ExpandStream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "source" : 
            "name" : "source"
            "qualifiedname" : "dart.async._ExpandStream._ExpandStream#source"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
          "expand" : 
            "name" : "expand"
            "qualifiedname" : "dart.async._ExpandStream._ExpandStream#expand"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_handleData" : 
        "name" : "_handleData"
        "qualifiedname" : "dart.async._ExpandStream._handleData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "inputEvent" : 
            "name" : "inputEvent"
            "qualifiedname" : "dart.async._ExpandStream._handleData#inputEvent"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._ExpandStream.S"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._ExpandStream._handleData#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSink"
            "value" : "null"
  "_MapStream" : 
    "name" : "_MapStream"
    "qualifiedname" : "dart.async._MapStream"
    "comment" : "<p>A stream pipe that converts data events before passing them on.</p>"
    "superclass" : "dart.async._ForwardingStream"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_transform" : 
        "name" : "_transform"
        "qualifiedname" : "dart.async._MapStream._transform"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._Transformation"
    "methods" : 
      "_MapStream" : 
        "name" : "_MapStream"
        "qualifiedname" : "dart.async._MapStream._MapStream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "source" : 
            "name" : "source"
            "qualifiedname" : "dart.async._MapStream._MapStream#source"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
          "transform" : 
            "name" : "transform"
            "qualifiedname" : "dart.async._MapStream._MapStream#transform"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_handleData" : 
        "name" : "_handleData"
        "qualifiedname" : "dart.async._MapStream._handleData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "inputEvent" : 
            "name" : "inputEvent"
            "qualifiedname" : "dart.async._MapStream._handleData#inputEvent"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._MapStream.S"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._MapStream._handleData#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSink"
            "value" : "null"
  "_Transformation" : 
    "name" : "_Transformation"
    "qualifiedname" : "dart.async._Transformation"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_WhereStream" : 
    "name" : "_WhereStream"
    "qualifiedname" : "dart.async._WhereStream"
    "comment" : ""
    "superclass" : "dart.async._ForwardingStream"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_test" : 
        "name" : "_test"
        "qualifiedname" : "dart.async._WhereStream._test"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._Predicate"
    "methods" : 
      "_WhereStream" : 
        "name" : "_WhereStream"
        "qualifiedname" : "dart.async._WhereStream._WhereStream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "source" : 
            "name" : "source"
            "qualifiedname" : "dart.async._WhereStream._WhereStream#source"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async._WhereStream._WhereStream#test"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_handleData" : 
        "name" : "_handleData"
        "qualifiedname" : "dart.async._WhereStream._handleData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "inputEvent" : 
            "name" : "inputEvent"
            "qualifiedname" : "dart.async._WhereStream._handleData#inputEvent"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._WhereStream.T"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._WhereStream._handleData#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSink"
            "value" : "null"
  "_Predicate" : 
    "name" : "_Predicate"
    "qualifiedname" : "dart.async._Predicate"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_ForwardingStreamSubscription" : 
    "name" : "_ForwardingStreamSubscription"
    "qualifiedname" : "dart.async._ForwardingStreamSubscription"
    "comment" : "<p>Abstract superclass for subscriptions that forward to other subscriptions.</p>"
    "superclass" : "dart.async._BufferingStreamSubscription"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_stream" : 
        "name" : "_stream"
        "qualifiedname" : "dart.async._ForwardingStreamSubscription._stream"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._ForwardingStream"
      "_subscription" : 
        "name" : "_subscription"
        "qualifiedname" : "dart.async._ForwardingStreamSubscription._subscription"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async.StreamSubscription"
    "methods" : 
      "_ForwardingStreamSubscription" : 
        "name" : "_ForwardingStreamSubscription"
        "qualifiedname" : "dart.async._ForwardingStreamSubscription._ForwardingStreamSubscription"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_stream" : 
            "name" : "_stream"
            "qualifiedname" : "dart.async._ForwardingStreamSubscription._ForwardingStreamSubscription#_stream"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._ForwardingStream"
            "value" : "null"
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async._ForwardingStreamSubscription._ForwardingStreamSubscription#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async._ForwardingStreamSubscription._ForwardingStreamSubscription#onError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async._ForwardingStreamSubscription._ForwardingStreamSubscription#onDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async._ForwardingStreamSubscription._ForwardingStreamSubscription#cancelOnError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
      "_add" : 
        "name" : "_add"
        "qualifiedname" : "dart.async._ForwardingStreamSubscription._add"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._ForwardingStreamSubscription._add#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._ForwardingStreamSubscription.T"
            "value" : "null"
      "_addError" : 
        "name" : "_addError"
        "qualifiedname" : "dart.async._ForwardingStreamSubscription._addError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._ForwardingStreamSubscription._addError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "_onPause" : 
        "name" : "_onPause"
        "qualifiedname" : "dart.async._ForwardingStreamSubscription._onPause"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_onResume" : 
        "name" : "_onResume"
        "qualifiedname" : "dart.async._ForwardingStreamSubscription._onResume"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_onCancel" : 
        "name" : "_onCancel"
        "qualifiedname" : "dart.async._ForwardingStreamSubscription._onCancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_handleData" : 
        "name" : "_handleData"
        "qualifiedname" : "dart.async._ForwardingStreamSubscription._handleData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._ForwardingStreamSubscription._handleData#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "_handleError" : 
        "name" : "_handleError"
        "qualifiedname" : "dart.async._ForwardingStreamSubscription._handleError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._ForwardingStreamSubscription._handleError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "_handleDone" : 
        "name" : "_handleDone"
        "qualifiedname" : "dart.async._ForwardingStreamSubscription._handleDone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_ForwardingStream" : 
    "name" : "_ForwardingStream"
    "qualifiedname" : "dart.async._ForwardingStream"
    "comment" : "<p>A <code>Stream</code> that forwards subscriptions to another stream.</p> <p>This stream implements <code>Stream</code>, but forwards all subscriptions to an underlying stream, and wraps the returned subscription to modify the events on the way.</p> <p>This class is intended for internal use only.</p>"
    "superclass" : "dart.async.Stream"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_source" : 
        "name" : "_source"
        "qualifiedname" : "dart.async._ForwardingStream._source"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async.Stream"
    "methods" : 
      "_ForwardingStream" : 
        "name" : "_ForwardingStream"
        "qualifiedname" : "dart.async._ForwardingStream._ForwardingStream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_source" : 
            "name" : "_source"
            "qualifiedname" : "dart.async._ForwardingStream._ForwardingStream#_source"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
      "isBroadcast" : 
        "name" : "isBroadcast"
        "qualifiedname" : "dart.async._ForwardingStream.isBroadcast"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "listen" : 
        "name" : "listen"
        "qualifiedname" : "dart.async._ForwardingStream.listen"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.StreamSubscription"
        "parameters" : 
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async._ForwardingStream.listen#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async._ForwardingStream.listen#onError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async._ForwardingStream.listen#onDone"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async._ForwardingStream.listen#cancelOnError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
      "_createSubscription" : 
        "name" : "_createSubscription"
        "qualifiedname" : "dart.async._ForwardingStream._createSubscription"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.StreamSubscription"
        "parameters" : 
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async._ForwardingStream._createSubscription#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async._ForwardingStream._createSubscription#onError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async._ForwardingStream._createSubscription#onDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async._ForwardingStream._createSubscription#cancelOnError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
      "_handleData" : 
        "name" : "_handleData"
        "qualifiedname" : "dart.async._ForwardingStream._handleData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._ForwardingStream._handleData#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._ForwardingStream.S"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._ForwardingStream._handleData#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSink"
            "value" : "null"
      "_handleError" : 
        "name" : "_handleError"
        "qualifiedname" : "dart.async._ForwardingStream._handleError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._ForwardingStream._handleError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._ForwardingStream._handleError#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSink"
            "value" : "null"
      "_handleDone" : 
        "name" : "_handleDone"
        "qualifiedname" : "dart.async._ForwardingStream._handleDone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async._ForwardingStream._handleDone#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSink"
            "value" : "null"
  "_StreamIteratorImpl" : 
    "name" : "_StreamIteratorImpl"
    "qualifiedname" : "dart.async._StreamIteratorImpl"
    "comment" : "<p>Simple implementation of <code>StreamIterator</code>.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
      - "dart.async.StreamIterator"
    "variables" : 
      "_STATE_FOUND" : 
        "name" : "_STATE_FOUND"
        "qualifiedname" : "dart.async._StreamIteratorImpl._STATE_FOUND"
        "comment" : "<p>The simple state where <code>_data</code> holds the data to return, and <code>moveNext</code> is allowed. The subscription is actively listening.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_DONE" : 
        "name" : "_STATE_DONE"
        "qualifiedname" : "dart.async._StreamIteratorImpl._STATE_DONE"
        "comment" : "<p>State set after <code>moveNext</code> has returned false or an error, or after calling <code>cancel</code>. The subscription is always canceled.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_MOVING" : 
        "name" : "_STATE_MOVING"
        "qualifiedname" : "dart.async._StreamIteratorImpl._STATE_MOVING"
        "comment" : "<p>State set after calling <code>moveNext</code>, but before its returned future has completed. Calling <code>moveNext</code> again is not allowed in this state. The subscription is actively listening.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_EXTRA_DATA" : 
        "name" : "_STATE_EXTRA_DATA"
        "qualifiedname" : "dart.async._StreamIteratorImpl._STATE_EXTRA_DATA"
        "comment" : "<p>States set when another event occurs while in <em>STATE</em>FOUND. This extra overflow event is cached until the next call to <code>moveNext</code>, which will complete as if it received the event normally. The subscription is paused in these states, so we only ever get one event too many.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_EXTRA_ERROR" : 
        "name" : "_STATE_EXTRA_ERROR"
        "qualifiedname" : "dart.async._StreamIteratorImpl._STATE_EXTRA_ERROR"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_EXTRA_DONE" : 
        "name" : "_STATE_EXTRA_DONE"
        "qualifiedname" : "dart.async._StreamIteratorImpl._STATE_EXTRA_DONE"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_subscription" : 
        "name" : "_subscription"
        "qualifiedname" : "dart.async._StreamIteratorImpl._subscription"
        "comment" : "<p>Subscription being listened to.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dart.async.StreamSubscription"
      "_current" : 
        "name" : "_current"
        "qualifiedname" : "dart.async._StreamIteratorImpl._current"
        "comment" : "<p>The current element represented by the most recent call to moveNext.  Is null between the time moveNext is called and its future completes.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._StreamIteratorImpl.T"
      "_futureOrPrefetch" : 
        "name" : "_futureOrPrefetch"
        "qualifiedname" : "dart.async._StreamIteratorImpl._futureOrPrefetch"
        "comment" : "<p>The future returned by the most recent call to <code>moveNext</code>.  Also used to store the next value/error in case the stream provides an event before <code>moveNext</code> is called again. In that case, the stream will be paused to prevent further events.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dynamic"
      "_state" : 
        "name" : "_state"
        "qualifiedname" : "dart.async._StreamIteratorImpl._state"
        "comment" : "<p>The current state.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.int"
    "methods" : 
      "_StreamIteratorImpl" : 
        "name" : "_StreamIteratorImpl"
        "qualifiedname" : "dart.async._StreamIteratorImpl._StreamIteratorImpl"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "stream" : 
            "name" : "stream"
            "qualifiedname" : "dart.async._StreamIteratorImpl._StreamIteratorImpl#stream"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
      "current" : 
        "name" : "current"
        "qualifiedname" : "dart.async._StreamIteratorImpl.current"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async._StreamIteratorImpl.T"
        "parameters" : 
      "moveNext" : 
        "name" : "moveNext"
        "qualifiedname" : "dart.async._StreamIteratorImpl.moveNext"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
      "_clear" : 
        "name" : "_clear"
        "qualifiedname" : "dart.async._StreamIteratorImpl._clear"
        "comment" : "<p>Clears up the internal state when the iterator ends.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "cancel" : 
        "name" : "cancel"
        "qualifiedname" : "dart.async._StreamIteratorImpl.cancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_onData" : 
        "name" : "_onData"
        "qualifiedname" : "dart.async._StreamIteratorImpl._onData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._StreamIteratorImpl._onData#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._StreamIteratorImpl.T"
            "value" : "null"
      "_onError" : 
        "name" : "_onError"
        "qualifiedname" : "dart.async._StreamIteratorImpl._onError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._StreamIteratorImpl._onError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "_onDone" : 
        "name" : "_onDone"
        "qualifiedname" : "dart.async._StreamIteratorImpl._onDone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_AsBroadcastStream" : 
    "name" : "_AsBroadcastStream"
    "qualifiedname" : "dart.async._AsBroadcastStream"
    "comment" : ""
    "superclass" : "dart.async.Stream"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_source" : 
        "name" : "_source"
        "qualifiedname" : "dart.async._AsBroadcastStream._source"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async.Stream"
      "_controller" : 
        "name" : "_controller"
        "qualifiedname" : "dart.async._AsBroadcastStream._controller"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._AsBroadcastStreamController"
      "_subscription" : 
        "name" : "_subscription"
        "qualifiedname" : "dart.async._AsBroadcastStream._subscription"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async.StreamSubscription"
    "methods" : 
      "_AsBroadcastStream" : 
        "name" : "_AsBroadcastStream"
        "qualifiedname" : "dart.async._AsBroadcastStream._AsBroadcastStream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_source" : 
            "name" : "_source"
            "qualifiedname" : "dart.async._AsBroadcastStream._AsBroadcastStream#_source"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
      "isBroadcast" : 
        "name" : "isBroadcast"
        "qualifiedname" : "dart.async._AsBroadcastStream.isBroadcast"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "listen" : 
        "name" : "listen"
        "qualifiedname" : "dart.async._AsBroadcastStream.listen"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.StreamSubscription"
        "parameters" : 
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async._AsBroadcastStream.listen#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async._AsBroadcastStream.listen#onError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async._AsBroadcastStream.listen#onDone"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async._AsBroadcastStream.listen#cancelOnError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
      "_onCancel" : 
        "name" : "_onCancel"
        "qualifiedname" : "dart.async._AsBroadcastStream._onCancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_BroadcastLinkedList" : 
    "name" : "_BroadcastLinkedList"
    "qualifiedname" : "dart.async._BroadcastLinkedList"
    "comment" : ""
    "superclass" : "dart.core.Object"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_next" : 
        "name" : "_next"
        "qualifiedname" : "dart.async._BroadcastLinkedList._next"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._BroadcastLinkedList"
      "_previous" : 
        "name" : "_previous"
        "qualifiedname" : "dart.async._BroadcastLinkedList._previous"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._BroadcastLinkedList"
    "methods" : 
      "_unlink" : 
        "name" : "_unlink"
        "qualifiedname" : "dart.async._BroadcastLinkedList._unlink"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_insertBefore" : 
        "name" : "_insertBefore"
        "qualifiedname" : "dart.async._BroadcastLinkedList._insertBefore"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "newNext" : 
            "name" : "newNext"
            "qualifiedname" : "dart.async._BroadcastLinkedList._insertBefore#newNext"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._BroadcastLinkedList"
            "value" : "null"
  "_StreamImplEvents" : 
    "name" : "_StreamImplEvents"
    "qualifiedname" : "dart.async._StreamImplEvents"
    "comment" : "<p>Class holding pending events for a <code>_StreamImpl</code>.</p>"
    "superclass" : "dart.async._PendingEvents"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "firstPendingEvent" : 
        "name" : "firstPendingEvent"
        "qualifiedname" : "dart.async._StreamImplEvents.firstPendingEvent"
        "comment" : "<p>Single linked list of <code>_DelayedEvent</code> objects.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._DelayedEvent"
      "lastPendingEvent" : 
        "name" : "lastPendingEvent"
        "qualifiedname" : "dart.async._StreamImplEvents.lastPendingEvent"
        "comment" : "<p>Last element in the list of pending events. New events are added after it.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._DelayedEvent"
    "methods" : 
      "isEmpty" : 
        "name" : "isEmpty"
        "qualifiedname" : "dart.async._StreamImplEvents.isEmpty"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "add" : 
        "name" : "add"
        "qualifiedname" : "dart.async._StreamImplEvents.add"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "event" : 
            "name" : "event"
            "qualifiedname" : "dart.async._StreamImplEvents.add#event"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._DelayedEvent"
            "value" : "null"
      "handleNext" : 
        "name" : "handleNext"
        "qualifiedname" : "dart.async._StreamImplEvents.handleNext"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "dispatch" : 
            "name" : "dispatch"
            "qualifiedname" : "dart.async._StreamImplEvents.handleNext#dispatch"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventDispatch"
            "value" : "null"
      "clear" : 
        "name" : "clear"
        "qualifiedname" : "dart.async._StreamImplEvents.clear"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_PendingEvents" : 
    "name" : "_PendingEvents"
    "qualifiedname" : "dart.async._PendingEvents"
    "comment" : "<p>Superclass for provider of pending events.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_STATE_UNSCHEDULED" : 
        "name" : "_STATE_UNSCHEDULED"
        "qualifiedname" : "dart.async._PendingEvents._STATE_UNSCHEDULED"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_SCHEDULED" : 
        "name" : "_STATE_SCHEDULED"
        "qualifiedname" : "dart.async._PendingEvents._STATE_SCHEDULED"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_CANCELED" : 
        "name" : "_STATE_CANCELED"
        "qualifiedname" : "dart.async._PendingEvents._STATE_CANCELED"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_state" : 
        "name" : "_state"
        "qualifiedname" : "dart.async._PendingEvents._state"
        "comment" : "<p>State of being scheduled.</p> <p>Set to [_STATE_SCHEDULED] when pending events are scheduled for async dispatch. Since we can't cancel a <code>runAsync</code> call, if schduling is \"canceled\", the <em>state is simply set to [</em>STATE<em>CANCELED] which will make the async code do nothing except resetting [</em>state].</p> <p>If events are scheduled while the state is [_STATE_CANCELED], it is merely switched back to [_STATE_SCHEDULED], but no new call to <code>runAsync</code> is performed.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.int"
    "methods" : 
      "isEmpty" : 
        "name" : "isEmpty"
        "qualifiedname" : "dart.async._PendingEvents.isEmpty"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "isScheduled" : 
        "name" : "isScheduled"
        "qualifiedname" : "dart.async._PendingEvents.isScheduled"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_eventScheduled" : 
        "name" : "_eventScheduled"
        "qualifiedname" : "dart.async._PendingEvents._eventScheduled"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "schedule" : 
        "name" : "schedule"
        "qualifiedname" : "dart.async._PendingEvents.schedule"
        "comment" : "<p>Schedule an event to run later.</p> <p>If called more than once, it should be called with the same dispatch as argument each time. It may reuse an earlier argument in some cases.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "dispatch" : 
            "name" : "dispatch"
            "qualifiedname" : "dart.async._PendingEvents.schedule#dispatch"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventDispatch"
            "value" : "null"
      "cancelSchedule" : 
        "name" : "cancelSchedule"
        "qualifiedname" : "dart.async._PendingEvents.cancelSchedule"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "handleNext" : 
        "name" : "handleNext"
        "qualifiedname" : "dart.async._PendingEvents.handleNext"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "dispatch" : 
            "name" : "dispatch"
            "qualifiedname" : "dart.async._PendingEvents.handleNext#dispatch"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventDispatch"
            "value" : "null"
      "clear" : 
        "name" : "clear"
        "qualifiedname" : "dart.async._PendingEvents.clear"
        "comment" : "<p>Throw away any pending events and cancel scheduled events.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_DelayedDone" : 
    "name" : "_DelayedDone"
    "qualifiedname" : "dart.async._DelayedDone"
    "comment" : "<p>A delayed done event.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
      - "dart.async._DelayedEvent"
    "variables" : 
    "methods" : 
      "_DelayedDone" : 
        "name" : "_DelayedDone"
        "qualifiedname" : "dart.async._DelayedDone._DelayedDone"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
      "perform" : 
        "name" : "perform"
        "qualifiedname" : "dart.async._DelayedDone.perform"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "dispatch" : 
            "name" : "dispatch"
            "qualifiedname" : "dart.async._DelayedDone.perform#dispatch"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventDispatch"
            "value" : "null"
      "next" : 
        "name" : "next"
        "qualifiedname" : "dart.async._DelayedDone.next"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async._DelayedEvent"
        "parameters" : 
      "next=" : 
        "name" : "next="
        "qualifiedname" : "dart.async._DelayedDone.next="
        "comment" : ""
        "type" : "setter"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "_" : 
            "name" : "_"
            "qualifiedname" : "dart.async._DelayedDone.next=#_"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._DelayedEvent"
            "value" : "null"
  "_DelayedError" : 
    "name" : "_DelayedError"
    "qualifiedname" : "dart.async._DelayedError"
    "comment" : "<p>A delayed error event.</p>"
    "superclass" : "dart.async._DelayedEvent"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "error" : 
        "name" : "error"
        "qualifiedname" : "dart.async._DelayedError.error"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dynamic"
    "methods" : 
      "_DelayedError" : 
        "name" : "_DelayedError"
        "qualifiedname" : "dart.async._DelayedError._DelayedError"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._DelayedError._DelayedError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "perform" : 
        "name" : "perform"
        "qualifiedname" : "dart.async._DelayedError.perform"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "dispatch" : 
            "name" : "dispatch"
            "qualifiedname" : "dart.async._DelayedError.perform#dispatch"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventDispatch"
            "value" : "null"
  "_DelayedData" : 
    "name" : "_DelayedData"
    "qualifiedname" : "dart.async._DelayedData"
    "comment" : "<p>A delayed data event.</p>"
    "superclass" : "dart.async._DelayedEvent"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "value" : 
        "name" : "value"
        "qualifiedname" : "dart.async._DelayedData.value"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._DelayedData.T"
    "methods" : 
      "_DelayedData" : 
        "name" : "_DelayedData"
        "qualifiedname" : "dart.async._DelayedData._DelayedData"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._DelayedData._DelayedData#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._DelayedData.T"
            "value" : "null"
      "perform" : 
        "name" : "perform"
        "qualifiedname" : "dart.async._DelayedData.perform"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "dispatch" : 
            "name" : "dispatch"
            "qualifiedname" : "dart.async._DelayedData.perform#dispatch"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventDispatch"
            "value" : "null"
  "_DelayedEvent" : 
    "name" : "_DelayedEvent"
    "qualifiedname" : "dart.async._DelayedEvent"
    "comment" : "<p>A delayed event on a buffering stream subscription.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "next" : 
        "name" : "next"
        "qualifiedname" : "dart.async._DelayedEvent.next"
        "comment" : "<p>Added as a linked list on the <code>StreamController</code>.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._DelayedEvent"
    "methods" : 
      "perform" : 
        "name" : "perform"
        "qualifiedname" : "dart.async._DelayedEvent.perform"
        "comment" : "<p>Execute the delayed event on the <code>StreamController</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "dispatch" : 
            "name" : "dispatch"
            "qualifiedname" : "dart.async._DelayedEvent.perform#dispatch"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventDispatch"
            "value" : "null"
  "_DoneHandler" : 
    "name" : "_DoneHandler"
    "qualifiedname" : "dart.async._DoneHandler"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_ErrorHandler" : 
    "name" : "_ErrorHandler"
    "qualifiedname" : "dart.async._ErrorHandler"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_DataHandler" : 
    "name" : "_DataHandler"
    "qualifiedname" : "dart.async._DataHandler"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_IterablePendingEvents" : 
    "name" : "_IterablePendingEvents"
    "qualifiedname" : "dart.async._IterablePendingEvents"
    "comment" : "<p>Pending events object that gets its events from an <code>Iterable</code>.</p>"
    "superclass" : "dart.async._PendingEvents"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_iterator" : 
        "name" : "_iterator"
        "qualifiedname" : "dart.async._IterablePendingEvents._iterator"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.Iterator"
    "methods" : 
      "_IterablePendingEvents" : 
        "name" : "_IterablePendingEvents"
        "qualifiedname" : "dart.async._IterablePendingEvents._IterablePendingEvents"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._IterablePendingEvents._IterablePendingEvents#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Iterable"
            "value" : "null"
      "isEmpty" : 
        "name" : "isEmpty"
        "qualifiedname" : "dart.async._IterablePendingEvents.isEmpty"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "handleNext" : 
        "name" : "handleNext"
        "qualifiedname" : "dart.async._IterablePendingEvents.handleNext"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "dispatch" : 
            "name" : "dispatch"
            "qualifiedname" : "dart.async._IterablePendingEvents.handleNext#dispatch"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventDispatch"
            "value" : "null"
      "clear" : 
        "name" : "clear"
        "qualifiedname" : "dart.async._IterablePendingEvents.clear"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_GeneratedStreamImpl" : 
    "name" : "_GeneratedStreamImpl"
    "qualifiedname" : "dart.async._GeneratedStreamImpl"
    "comment" : "<p>Stream that generates its own events.</p>"
    "superclass" : "dart.async._StreamImpl"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_pending" : 
        "name" : "_pending"
        "qualifiedname" : "dart.async._GeneratedStreamImpl._pending"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._EventGenerator"
    "methods" : 
      "_GeneratedStreamImpl" : 
        "name" : "_GeneratedStreamImpl"
        "qualifiedname" : "dart.async._GeneratedStreamImpl._GeneratedStreamImpl"
        "comment" : "<p>Initializes the stream to have only the events provided by a <code>_PendingEvents</code>.</p> <p>A new <code>_PendingEvents</code> must be generated for each listen.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_pending" : 
            "name" : "_pending"
            "qualifiedname" : "dart.async._GeneratedStreamImpl._GeneratedStreamImpl#_pending"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventGenerator"
            "value" : "null"
      "_createSubscription" : 
        "name" : "_createSubscription"
        "qualifiedname" : "dart.async._GeneratedStreamImpl._createSubscription"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.StreamSubscription"
        "parameters" : 
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async._GeneratedStreamImpl._createSubscription#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async._GeneratedStreamImpl._createSubscription#onError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async._GeneratedStreamImpl._createSubscription#onDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async._GeneratedStreamImpl._createSubscription#cancelOnError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
  "_EventGenerator" : 
    "name" : "_EventGenerator"
    "qualifiedname" : "dart.async._EventGenerator"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_StreamImpl" : 
    "name" : "_StreamImpl"
    "qualifiedname" : "dart.async._StreamImpl"
    "comment" : ""
    "superclass" : "dart.async.Stream"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "listen" : 
        "name" : "listen"
        "qualifiedname" : "dart.async._StreamImpl.listen"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.StreamSubscription"
        "parameters" : 
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async._StreamImpl.listen#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async._StreamImpl.listen#onError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async._StreamImpl.listen#onDone"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async._StreamImpl.listen#cancelOnError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
      "_createSubscription" : 
        "name" : "_createSubscription"
        "qualifiedname" : "dart.async._StreamImpl._createSubscription"
        "comment" : "<p>Create a subscription object. Called by <code>subcribe</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async._BufferingStreamSubscription"
        "parameters" : 
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async._StreamImpl._createSubscription#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async._StreamImpl._createSubscription#onError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async._StreamImpl._createSubscription#onDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async._StreamImpl._createSubscription#cancelOnError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
      "_onListen" : 
        "name" : "_onListen"
        "qualifiedname" : "dart.async._StreamImpl._onListen"
        "comment" : "<p>Hook called when the subscription has been created.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._StreamImpl._onListen#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamSubscription"
            "value" : "null"
  "_BufferingStreamSubscription" : 
    "name" : "_BufferingStreamSubscription"
    "qualifiedname" : "dart.async._BufferingStreamSubscription"
    "comment" : "<p>Default implementation of stream subscription of buffering events.</p> <p>The only public methods are those of <code>StreamSubscription</code>, so instances of <code>_BufferingStreamSubscription</code> can be returned directly as a <code>StreamSubscription</code> without exposing internal functionality.</p> <p>The <code>StreamController</code> is a public facing version of <code>Stream</code> and this class, with some methods made public.</p> <p>The user interface of <code>_BufferingStreamSubscription</code> are the following methods: <em> <code>_add</code>: Add a data event to the stream. </em> <code>_addError</code>: Add an error event to the stream. <em> <code>_close</code>: Request to close the stream. </em> <code>_onCancel</code>: Called when the subscription will provide no more events,</p> <pre><code>either due to being actively canceled, or after sending a done event. </code></pre><ul><li><code>_onPause</code>: Called when the subscription wants the event source to pause.</li><li> <p><code>_onResume</code>: Called when allowing new events after a pause. The user should not add new events when the subscription requests a paused, but if it happens anyway, the subscription will enqueue the events just as when new events arrive while still firing an old event.</p></li></ul>"
    "superclass" : "dart.core.Object"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
      - "dart.async._EventDispatch"
      - "dart.async._EventSink"
      - "dart.async.StreamSubscription"
    "variables" : 
      "_STATE_CANCEL_ON_ERROR" : 
        "name" : "_STATE_CANCEL_ON_ERROR"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._STATE_CANCEL_ON_ERROR"
        "comment" : "<p>The <code>cancelOnError</code> flag from the <code>listen</code> call.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_CLOSED" : 
        "name" : "_STATE_CLOSED"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._STATE_CLOSED"
        "comment" : "<p>Whether the \"done\" event has been received. No further events are accepted after this.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_INPUT_PAUSED" : 
        "name" : "_STATE_INPUT_PAUSED"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._STATE_INPUT_PAUSED"
        "comment" : "<p>Set if the input has been asked not to send events.</p> <p>This is not the same as being paused, since the input will remain paused after a call to <code>resume</code> if there are pending events.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_CANCELED" : 
        "name" : "_STATE_CANCELED"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._STATE_CANCELED"
        "comment" : "<p>Whether the subscription has been canceled.</p> <p>Set by calling <code>cancel</code>, or by handling a \"done\" event, or an \"error\" event when <code>cancelOnError</code> is true.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_IN_CALLBACK" : 
        "name" : "_STATE_IN_CALLBACK"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._STATE_IN_CALLBACK"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_HAS_PENDING" : 
        "name" : "_STATE_HAS_PENDING"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._STATE_HAS_PENDING"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_PAUSE_COUNT" : 
        "name" : "_STATE_PAUSE_COUNT"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._STATE_PAUSE_COUNT"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_PAUSE_COUNT_SHIFT" : 
        "name" : "_STATE_PAUSE_COUNT_SHIFT"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._STATE_PAUSE_COUNT_SHIFT"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_onData" : 
        "name" : "_onData"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._onData"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.Function"
      "_onError" : 
        "name" : "_onError"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._onError"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._ErrorHandler"
      "_onDone" : 
        "name" : "_onDone"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._onDone"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._DoneHandler"
      "_zone" : 
        "name" : "_zone"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._zone"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._Zone"
      "_state" : 
        "name" : "_state"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._state"
        "comment" : "<p>Bit vector based on state-constants above.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.int"
      "_pending" : 
        "name" : "_pending"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._pending"
        "comment" : "<p>Queue of pending events.</p> <p>Is created when necessary, or set in constructor for preconfigured events.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._PendingEvents"
    "methods" : 
      "_BufferingStreamSubscription" : 
        "name" : "_BufferingStreamSubscription"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._BufferingStreamSubscription"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_onData" : 
            "name" : "_onData"
            "qualifiedname" : "dart.async._BufferingStreamSubscription._BufferingStreamSubscription#_onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "_onError" : 
            "name" : "_onError"
            "qualifiedname" : "dart.async._BufferingStreamSubscription._BufferingStreamSubscription#_onError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._ErrorHandler"
            "value" : "null"
          "_onDone" : 
            "name" : "_onDone"
            "qualifiedname" : "dart.async._BufferingStreamSubscription._BufferingStreamSubscription#_onDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._DoneHandler"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async._BufferingStreamSubscription._BufferingStreamSubscription#cancelOnError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
      "_setPendingEvents" : 
        "name" : "_setPendingEvents"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._setPendingEvents"
        "comment" : "<p>Sets the subscription's pending events object.</p> <p>This can only be done once. The pending events object is used for the rest of the subscription's life cycle.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "pendingEvents" : 
            "name" : "pendingEvents"
            "qualifiedname" : "dart.async._BufferingStreamSubscription._setPendingEvents#pendingEvents"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._PendingEvents"
            "value" : "null"
      "_extractPending" : 
        "name" : "_extractPending"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._extractPending"
        "comment" : "<p>Extracts the pending events from a canceled stream.</p> <p>This can only be done during the <code>_onCancel</code> method call. After that, any remaining pending events will be cleared.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async._PendingEvents"
        "parameters" : 
      "onData" : 
        "name" : "onData"
        "qualifiedname" : "dart.async._BufferingStreamSubscription.onData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "handleData" : 
            "name" : "handleData"
            "qualifiedname" : "dart.async._BufferingStreamSubscription.onData#handleData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "onError" : 
        "name" : "onError"
        "qualifiedname" : "dart.async._BufferingStreamSubscription.onError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "handleError" : 
            "name" : "handleError"
            "qualifiedname" : "dart.async._BufferingStreamSubscription.onError#handleError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "onDone" : 
        "name" : "onDone"
        "qualifiedname" : "dart.async._BufferingStreamSubscription.onDone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "handleDone" : 
            "name" : "handleDone"
            "qualifiedname" : "dart.async._BufferingStreamSubscription.onDone#handleDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "pause" : 
        "name" : "pause"
        "qualifiedname" : "dart.async._BufferingStreamSubscription.pause"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "resumeSignal" : 
            "name" : "resumeSignal"
            "qualifiedname" : "dart.async._BufferingStreamSubscription.pause#resumeSignal"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Future"
            "value" : "null"
      "resume" : 
        "name" : "resume"
        "qualifiedname" : "dart.async._BufferingStreamSubscription.resume"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "cancel" : 
        "name" : "cancel"
        "qualifiedname" : "dart.async._BufferingStreamSubscription.cancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "asFuture" : 
        "name" : "asFuture"
        "qualifiedname" : "dart.async._BufferingStreamSubscription.asFuture"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "futureValue" : 
            "name" : "futureValue"
            "qualifiedname" : "dart.async._BufferingStreamSubscription.asFuture#futureValue"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "_isInputPaused" : 
        "name" : "_isInputPaused"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._isInputPaused"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_isClosed" : 
        "name" : "_isClosed"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._isClosed"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_isCanceled" : 
        "name" : "_isCanceled"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._isCanceled"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_inCallback" : 
        "name" : "_inCallback"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._inCallback"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_hasPending" : 
        "name" : "_hasPending"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._hasPending"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_isPaused" : 
        "name" : "_isPaused"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._isPaused"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_canFire" : 
        "name" : "_canFire"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._canFire"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_mayResumeInput" : 
        "name" : "_mayResumeInput"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._mayResumeInput"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_cancelOnError" : 
        "name" : "_cancelOnError"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._cancelOnError"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "isPaused" : 
        "name" : "isPaused"
        "qualifiedname" : "dart.async._BufferingStreamSubscription.isPaused"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_cancel" : 
        "name" : "_cancel"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._cancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_incrementPauseCount" : 
        "name" : "_incrementPauseCount"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._incrementPauseCount"
        "comment" : "<p>Increment the pause count.</p> <p>Also marks input as paused.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_decrementPauseCount" : 
        "name" : "_decrementPauseCount"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._decrementPauseCount"
        "comment" : "<p>Decrements the pause count.</p> <p>Does not automatically unpause the input (call <code>_onResume</code>) when the pause count reaches zero. This is handled elsewhere, and only if there are no pending events buffered.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_add" : 
        "name" : "_add"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._add"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._BufferingStreamSubscription._add#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._BufferingStreamSubscription.T"
            "value" : "null"
      "_addError" : 
        "name" : "_addError"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._addError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._BufferingStreamSubscription._addError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "_close" : 
        "name" : "_close"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._close"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_onPause" : 
        "name" : "_onPause"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._onPause"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_onResume" : 
        "name" : "_onResume"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._onResume"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_onCancel" : 
        "name" : "_onCancel"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._onCancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_addPending" : 
        "name" : "_addPending"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._addPending"
        "comment" : "<p>Add a pending event.</p> <p>If the subscription is not paused, this also schedules a firing of pending events later (if necessary).</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "event" : 
            "name" : "event"
            "qualifiedname" : "dart.async._BufferingStreamSubscription._addPending#event"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._DelayedEvent"
            "value" : "null"
      "_sendData" : 
        "name" : "_sendData"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._sendData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._BufferingStreamSubscription._sendData#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._BufferingStreamSubscription.T"
            "value" : "null"
      "_sendError" : 
        "name" : "_sendError"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._sendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._BufferingStreamSubscription._sendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "_sendDone" : 
        "name" : "_sendDone"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._sendDone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_guardCallback" : 
        "name" : "_guardCallback"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._guardCallback"
        "comment" : "<p>Call a hook function.</p> <p>The call is properly wrapped in code to avoid other callbacks during the call, and it checks for state changes after the call that should cause further callbacks.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "callback" : 
            "name" : "callback"
            "qualifiedname" : "dart.async._BufferingStreamSubscription._guardCallback#callback"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "_checkState" : 
        "name" : "_checkState"
        "qualifiedname" : "dart.async._BufferingStreamSubscription._checkState"
        "comment" : "<p>Check if the input needs to be informed of state changes.</p> <p>State changes are pausing, resuming and canceling.</p> <p>After canceling, no further callbacks will happen.</p> <p>The cancel callback is called after a user cancel, or after the final done event is sent.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "wasInputPaused" : 
            "name" : "wasInputPaused"
            "qualifiedname" : "dart.async._BufferingStreamSubscription._checkState#wasInputPaused"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
  "_EventDispatch" : 
    "name" : "_EventDispatch"
    "qualifiedname" : "dart.async._EventDispatch"
    "comment" : "<p>Abstract and private interface for a place to send events.</p> <p>Used by event buffering to finally dispatch the pending event, where <code>_EventSink</code> is where the event first enters the stream subscription, and may yet be buffered.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "_sendData" : 
        "name" : "_sendData"
        "qualifiedname" : "dart.async._EventDispatch._sendData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._EventDispatch._sendData#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventDispatch.T"
            "value" : "null"
      "_sendError" : 
        "name" : "_sendError"
        "qualifiedname" : "dart.async._EventDispatch._sendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._EventDispatch._sendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "_sendDone" : 
        "name" : "_sendDone"
        "qualifiedname" : "dart.async._EventDispatch._sendDone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_EventSink" : 
    "name" : "_EventSink"
    "qualifiedname" : "dart.async._EventSink"
    "comment" : "<p>Abstract and private interface for a place to put events.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "_add" : 
        "name" : "_add"
        "qualifiedname" : "dart.async._EventSink._add"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._EventSink._add#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSink.T"
            "value" : "null"
      "_addError" : 
        "name" : "_addError"
        "qualifiedname" : "dart.async._EventSink._addError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._EventSink._addError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "_close" : 
        "name" : "_close"
        "qualifiedname" : "dart.async._EventSink._close"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_AsBroadcastStreamController" : 
    "name" : "_AsBroadcastStreamController"
    "qualifiedname" : "dart.async._AsBroadcastStreamController"
    "comment" : "<p>Stream controller that is used by <code>Stream.asBroadcastStream</code>.</p> <p>This stream controller allows incoming events while it is firing other events. This is handled by delaying the events until the current event is done firing, and then fire the pending events.</p> <p>This class extends <code>_SyncBroadcastStreamController</code>. Events of an \"asBroadcastStream\" stream are always initiated by events on another stream, and it is fine to forward them synchronously.</p>"
    "superclass" : "dart.async._SyncBroadcastStreamController"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
      - "dart.async._EventDispatch"
    "variables" : 
      "_pending" : 
        "name" : "_pending"
        "qualifiedname" : "dart.async._AsBroadcastStreamController._pending"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._StreamImplEvents"
    "methods" : 
      "_AsBroadcastStreamController" : 
        "name" : "_AsBroadcastStreamController"
        "qualifiedname" : "dart.async._AsBroadcastStreamController._AsBroadcastStreamController"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "onListen" : 
            "name" : "onListen"
            "qualifiedname" : "dart.async._AsBroadcastStreamController._AsBroadcastStreamController#onListen"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onCancel" : 
            "name" : "onCancel"
            "qualifiedname" : "dart.async._AsBroadcastStreamController._AsBroadcastStreamController#onCancel"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_hasPending" : 
        "name" : "_hasPending"
        "qualifiedname" : "dart.async._AsBroadcastStreamController._hasPending"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_addPendingEvent" : 
        "name" : "_addPendingEvent"
        "qualifiedname" : "dart.async._AsBroadcastStreamController._addPendingEvent"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "event" : 
            "name" : "event"
            "qualifiedname" : "dart.async._AsBroadcastStreamController._addPendingEvent#event"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._DelayedEvent"
            "value" : "null"
      "add" : 
        "name" : "add"
        "qualifiedname" : "dart.async._AsBroadcastStreamController.add"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._AsBroadcastStreamController.add#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._AsBroadcastStreamController.T"
            "value" : "null"
      "addError" : 
        "name" : "addError"
        "qualifiedname" : "dart.async._AsBroadcastStreamController.addError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._AsBroadcastStreamController.addError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
          "stackTrace" : 
            "name" : "stackTrace"
            "qualifiedname" : "dart.async._AsBroadcastStreamController.addError#stackTrace"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.StackTrace"
            "value" : "null"
      "close" : 
        "name" : "close"
        "qualifiedname" : "dart.async._AsBroadcastStreamController.close"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_callOnCancel" : 
        "name" : "_callOnCancel"
        "qualifiedname" : "dart.async._AsBroadcastStreamController._callOnCancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_AsyncBroadcastStreamController" : 
    "name" : "_AsyncBroadcastStreamController"
    "qualifiedname" : "dart.async._AsyncBroadcastStreamController"
    "comment" : ""
    "superclass" : "dart.async._BroadcastStreamController"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "_AsyncBroadcastStreamController" : 
        "name" : "_AsyncBroadcastStreamController"
        "qualifiedname" : "dart.async._AsyncBroadcastStreamController._AsyncBroadcastStreamController"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "onListen" : 
            "name" : "onListen"
            "qualifiedname" : "dart.async._AsyncBroadcastStreamController._AsyncBroadcastStreamController#onListen"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onCancel" : 
            "name" : "onCancel"
            "qualifiedname" : "dart.async._AsyncBroadcastStreamController._AsyncBroadcastStreamController#onCancel"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_sendData" : 
        "name" : "_sendData"
        "qualifiedname" : "dart.async._AsyncBroadcastStreamController._sendData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._AsyncBroadcastStreamController._sendData#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._AsyncBroadcastStreamController.T"
            "value" : "null"
      "_sendError" : 
        "name" : "_sendError"
        "qualifiedname" : "dart.async._AsyncBroadcastStreamController._sendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._AsyncBroadcastStreamController._sendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "_sendDone" : 
        "name" : "_sendDone"
        "qualifiedname" : "dart.async._AsyncBroadcastStreamController._sendDone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_SyncBroadcastStreamController" : 
    "name" : "_SyncBroadcastStreamController"
    "qualifiedname" : "dart.async._SyncBroadcastStreamController"
    "comment" : ""
    "superclass" : "dart.async._BroadcastStreamController"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "_SyncBroadcastStreamController" : 
        "name" : "_SyncBroadcastStreamController"
        "qualifiedname" : "dart.async._SyncBroadcastStreamController._SyncBroadcastStreamController"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "onListen" : 
            "name" : "onListen"
            "qualifiedname" : "dart.async._SyncBroadcastStreamController._SyncBroadcastStreamController#onListen"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onCancel" : 
            "name" : "onCancel"
            "qualifiedname" : "dart.async._SyncBroadcastStreamController._SyncBroadcastStreamController#onCancel"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_sendData" : 
        "name" : "_sendData"
        "qualifiedname" : "dart.async._SyncBroadcastStreamController._sendData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._SyncBroadcastStreamController._sendData#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._SyncBroadcastStreamController.T"
            "value" : "null"
      "_sendError" : 
        "name" : "_sendError"
        "qualifiedname" : "dart.async._SyncBroadcastStreamController._sendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._SyncBroadcastStreamController._sendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "_sendDone" : 
        "name" : "_sendDone"
        "qualifiedname" : "dart.async._SyncBroadcastStreamController._sendDone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_BroadcastStreamController" : 
    "name" : "_BroadcastStreamController"
    "qualifiedname" : "dart.async._BroadcastStreamController"
    "comment" : ""
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
      - "dart.async._EventDispatch"
      - "dart.async._BroadcastSubscriptionLink"
      - "dart.async._StreamControllerLifecycle"
      - "dart.async.StreamController"
    "variables" : 
      "_STATE_INITIAL" : 
        "name" : "_STATE_INITIAL"
        "qualifiedname" : "dart.async._BroadcastStreamController._STATE_INITIAL"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_EVENT_ID" : 
        "name" : "_STATE_EVENT_ID"
        "qualifiedname" : "dart.async._BroadcastStreamController._STATE_EVENT_ID"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_FIRING" : 
        "name" : "_STATE_FIRING"
        "qualifiedname" : "dart.async._BroadcastStreamController._STATE_FIRING"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_CLOSED" : 
        "name" : "_STATE_CLOSED"
        "qualifiedname" : "dart.async._BroadcastStreamController._STATE_CLOSED"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_onListen" : 
        "name" : "_onListen"
        "qualifiedname" : "dart.async._BroadcastStreamController._onListen"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._NotificationHandler"
      "_onCancel" : 
        "name" : "_onCancel"
        "qualifiedname" : "dart.async._BroadcastStreamController._onCancel"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._NotificationHandler"
      "_state" : 
        "name" : "_state"
        "qualifiedname" : "dart.async._BroadcastStreamController._state"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.int"
      "_next" : 
        "name" : "_next"
        "qualifiedname" : "dart.async._BroadcastStreamController._next"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._BroadcastSubscriptionLink"
      "_previous" : 
        "name" : "_previous"
        "qualifiedname" : "dart.async._BroadcastStreamController._previous"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._BroadcastSubscriptionLink"
    "methods" : 
      "_BroadcastStreamController" : 
        "name" : "_BroadcastStreamController"
        "qualifiedname" : "dart.async._BroadcastStreamController._BroadcastStreamController"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_onListen" : 
            "name" : "_onListen"
            "qualifiedname" : "dart.async._BroadcastStreamController._BroadcastStreamController#_onListen"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._NotificationHandler"
            "value" : "null"
          "_onCancel" : 
            "name" : "_onCancel"
            "qualifiedname" : "dart.async._BroadcastStreamController._BroadcastStreamController#_onCancel"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._NotificationHandler"
            "value" : "null"
      "stream" : 
        "name" : "stream"
        "qualifiedname" : "dart.async._BroadcastStreamController.stream"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
      "sink" : 
        "name" : "sink"
        "qualifiedname" : "dart.async._BroadcastStreamController.sink"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async.EventSink"
        "parameters" : 
      "isClosed" : 
        "name" : "isClosed"
        "qualifiedname" : "dart.async._BroadcastStreamController.isClosed"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "isPaused" : 
        "name" : "isPaused"
        "qualifiedname" : "dart.async._BroadcastStreamController.isPaused"
        "comment" : "<p>A broadcast controller is never paused.</p> <p>Each receiving stream may be paused individually, and they handle their own buffering.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "hasListener" : 
        "name" : "hasListener"
        "qualifiedname" : "dart.async._BroadcastStreamController.hasListener"
        "comment" : "<p>Whether there are currently a subscriber on the <code>Stream</code>.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_isFiring" : 
        "name" : "_isFiring"
        "qualifiedname" : "dart.async._BroadcastStreamController._isFiring"
        "comment" : "<p>Whether an event is being fired (sent to some, but not all, listeners).</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_isEmpty" : 
        "name" : "_isEmpty"
        "qualifiedname" : "dart.async._BroadcastStreamController._isEmpty"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_addListener" : 
        "name" : "_addListener"
        "qualifiedname" : "dart.async._BroadcastStreamController._addListener"
        "comment" : "<p>Adds subscription to linked list of active listeners.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._BroadcastStreamController._addListener#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._BroadcastSubscription"
            "value" : "null"
      "_removeListener" : 
        "name" : "_removeListener"
        "qualifiedname" : "dart.async._BroadcastStreamController._removeListener"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._BroadcastStreamController._removeListener#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._BroadcastSubscription"
            "value" : "null"
      "_recordListen" : 
        "name" : "_recordListen"
        "qualifiedname" : "dart.async._BroadcastStreamController._recordListen"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._BroadcastStreamController._recordListen#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._BroadcastSubscription"
            "value" : "null"
      "_recordCancel" : 
        "name" : "_recordCancel"
        "qualifiedname" : "dart.async._BroadcastStreamController._recordCancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._BroadcastStreamController._recordCancel#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._BroadcastSubscription"
            "value" : "null"
      "_recordPause" : 
        "name" : "_recordPause"
        "qualifiedname" : "dart.async._BroadcastStreamController._recordPause"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._BroadcastStreamController._recordPause#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamSubscription"
            "value" : "null"
      "_recordResume" : 
        "name" : "_recordResume"
        "qualifiedname" : "dart.async._BroadcastStreamController._recordResume"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._BroadcastStreamController._recordResume#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamSubscription"
            "value" : "null"
      "add" : 
        "name" : "add"
        "qualifiedname" : "dart.async._BroadcastStreamController.add"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._BroadcastStreamController.add#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._BroadcastStreamController.T"
            "value" : "null"
      "addError" : 
        "name" : "addError"
        "qualifiedname" : "dart.async._BroadcastStreamController.addError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._BroadcastStreamController.addError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
          "stackTrace" : 
            "name" : "stackTrace"
            "qualifiedname" : "dart.async._BroadcastStreamController.addError#stackTrace"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "close" : 
        "name" : "close"
        "qualifiedname" : "dart.async._BroadcastStreamController.close"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_forEachListener" : 
        "name" : "_forEachListener"
        "qualifiedname" : "dart.async._BroadcastStreamController._forEachListener"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "action" : 
            "name" : "action"
            "qualifiedname" : "dart.async._BroadcastStreamController._forEachListener#action"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_callOnCancel" : 
        "name" : "_callOnCancel"
        "qualifiedname" : "dart.async._BroadcastStreamController._callOnCancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_BroadcastSubscription" : 
    "name" : "_BroadcastSubscription"
    "qualifiedname" : "dart.async._BroadcastSubscription"
    "comment" : ""
    "superclass" : "dart.async._ControllerSubscription"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
      - "dart.async._BroadcastSubscriptionLink"
    "variables" : 
      "_STATE_EVENT_ID" : 
        "name" : "_STATE_EVENT_ID"
        "qualifiedname" : "dart.async._BroadcastSubscription._STATE_EVENT_ID"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_FIRING" : 
        "name" : "_STATE_FIRING"
        "qualifiedname" : "dart.async._BroadcastSubscription._STATE_FIRING"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_REMOVE_AFTER_FIRING" : 
        "name" : "_STATE_REMOVE_AFTER_FIRING"
        "qualifiedname" : "dart.async._BroadcastSubscription._STATE_REMOVE_AFTER_FIRING"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_eventState" : 
        "name" : "_eventState"
        "qualifiedname" : "dart.async._BroadcastSubscription._eventState"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.int"
      "_next" : 
        "name" : "_next"
        "qualifiedname" : "dart.async._BroadcastSubscription._next"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._BroadcastSubscriptionLink"
      "_previous" : 
        "name" : "_previous"
        "qualifiedname" : "dart.async._BroadcastSubscription._previous"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._BroadcastSubscriptionLink"
    "methods" : 
      "_BroadcastSubscription" : 
        "name" : "_BroadcastSubscription"
        "qualifiedname" : "dart.async._BroadcastSubscription._BroadcastSubscription"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "controller" : 
            "name" : "controller"
            "qualifiedname" : "dart.async._BroadcastSubscription._BroadcastSubscription#controller"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._StreamControllerLifecycle"
            "value" : "null"
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async._BroadcastSubscription._BroadcastSubscription#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async._BroadcastSubscription._BroadcastSubscription#onError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async._BroadcastSubscription._BroadcastSubscription#onDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async._BroadcastSubscription._BroadcastSubscription#cancelOnError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
      "_controller" : 
        "name" : "_controller"
        "qualifiedname" : "dart.async._BroadcastSubscription._controller"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async._BroadcastStreamController"
        "parameters" : 
      "_expectsEvent" : 
        "name" : "_expectsEvent"
        "qualifiedname" : "dart.async._BroadcastSubscription._expectsEvent"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
          "eventId" : 
            "name" : "eventId"
            "qualifiedname" : "dart.async._BroadcastSubscription._expectsEvent#eventId"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.int"
            "value" : "null"
      "_toggleEventId" : 
        "name" : "_toggleEventId"
        "qualifiedname" : "dart.async._BroadcastSubscription._toggleEventId"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_isFiring" : 
        "name" : "_isFiring"
        "qualifiedname" : "dart.async._BroadcastSubscription._isFiring"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_setRemoveAfterFiring" : 
        "name" : "_setRemoveAfterFiring"
        "qualifiedname" : "dart.async._BroadcastSubscription._setRemoveAfterFiring"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_removeAfterFiring" : 
        "name" : "_removeAfterFiring"
        "qualifiedname" : "dart.async._BroadcastSubscription._removeAfterFiring"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
  "_BroadcastSubscriptionLink" : 
    "name" : "_BroadcastSubscriptionLink"
    "qualifiedname" : "dart.async._BroadcastSubscriptionLink"
    "comment" : ""
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_next" : 
        "name" : "_next"
        "qualifiedname" : "dart.async._BroadcastSubscriptionLink._next"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._BroadcastSubscriptionLink"
      "_previous" : 
        "name" : "_previous"
        "qualifiedname" : "dart.async._BroadcastSubscriptionLink._previous"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._BroadcastSubscriptionLink"
    "methods" : 
  "_BroadcastStream" : 
    "name" : "_BroadcastStream"
    "qualifiedname" : "dart.async._BroadcastStream"
    "comment" : ""
    "superclass" : "dart.async._StreamImpl"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_controller" : 
        "name" : "_controller"
        "qualifiedname" : "dart.async._BroadcastStream._controller"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._BroadcastStreamController"
    "methods" : 
      "_BroadcastStream" : 
        "name" : "_BroadcastStream"
        "qualifiedname" : "dart.async._BroadcastStream._BroadcastStream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_controller" : 
            "name" : "_controller"
            "qualifiedname" : "dart.async._BroadcastStream._BroadcastStream#_controller"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._BroadcastStreamController"
            "value" : "null"
      "isBroadcast" : 
        "name" : "isBroadcast"
        "qualifiedname" : "dart.async._BroadcastStream.isBroadcast"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_createSubscription" : 
        "name" : "_createSubscription"
        "qualifiedname" : "dart.async._BroadcastStream._createSubscription"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.StreamSubscription"
        "parameters" : 
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async._BroadcastStream._createSubscription#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async._BroadcastStream._createSubscription#onError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async._BroadcastStream._createSubscription#onDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async._BroadcastStream._createSubscription#cancelOnError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
      "_onListen" : 
        "name" : "_onListen"
        "qualifiedname" : "dart.async._BroadcastStream._onListen"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._BroadcastStream._onListen#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._BufferingStreamSubscription"
            "value" : "null"
  "_ControllerSubscription" : 
    "name" : "_ControllerSubscription"
    "qualifiedname" : "dart.async._ControllerSubscription"
    "comment" : ""
    "superclass" : "dart.async._BufferingStreamSubscription"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_controller" : 
        "name" : "_controller"
        "qualifiedname" : "dart.async._ControllerSubscription._controller"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._StreamControllerLifecycle"
    "methods" : 
      "_ControllerSubscription" : 
        "name" : "_ControllerSubscription"
        "qualifiedname" : "dart.async._ControllerSubscription._ControllerSubscription"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_controller" : 
            "name" : "_controller"
            "qualifiedname" : "dart.async._ControllerSubscription._ControllerSubscription#_controller"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._StreamControllerLifecycle"
            "value" : "null"
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async._ControllerSubscription._ControllerSubscription#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async._ControllerSubscription._ControllerSubscription#onError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async._ControllerSubscription._ControllerSubscription#onDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async._ControllerSubscription._ControllerSubscription#cancelOnError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
      "_onCancel" : 
        "name" : "_onCancel"
        "qualifiedname" : "dart.async._ControllerSubscription._onCancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_onPause" : 
        "name" : "_onPause"
        "qualifiedname" : "dart.async._ControllerSubscription._onPause"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_onResume" : 
        "name" : "_onResume"
        "qualifiedname" : "dart.async._ControllerSubscription._onResume"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_ControllerStream" : 
    "name" : "_ControllerStream"
    "qualifiedname" : "dart.async._ControllerStream"
    "comment" : ""
    "superclass" : "dart.async._StreamImpl"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_controller" : 
        "name" : "_controller"
        "qualifiedname" : "dart.async._ControllerStream._controller"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._StreamControllerLifecycle"
      "_hasListener" : 
        "name" : "_hasListener"
        "qualifiedname" : "dart.async._ControllerStream._hasListener"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.bool"
    "methods" : 
      "_ControllerStream" : 
        "name" : "_ControllerStream"
        "qualifiedname" : "dart.async._ControllerStream._ControllerStream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_controller" : 
            "name" : "_controller"
            "qualifiedname" : "dart.async._ControllerStream._ControllerStream#_controller"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._StreamControllerLifecycle"
            "value" : "null"
      "_createSubscription" : 
        "name" : "_createSubscription"
        "qualifiedname" : "dart.async._ControllerStream._createSubscription"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.StreamSubscription"
        "parameters" : 
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async._ControllerStream._createSubscription#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async._ControllerStream._createSubscription#onError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async._ControllerStream._createSubscription#onDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async._ControllerStream._createSubscription#cancelOnError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
      "_onListen" : 
        "name" : "_onListen"
        "qualifiedname" : "dart.async._ControllerStream._onListen"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._ControllerStream._onListen#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._BufferingStreamSubscription"
            "value" : "null"
  "_NotificationHandler" : 
    "name" : "_NotificationHandler"
    "qualifiedname" : "dart.async._NotificationHandler"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_AsyncStreamController" : 
    "name" : "_AsyncStreamController"
    "qualifiedname" : "dart.async._AsyncStreamController"
    "comment" : ""
    "superclass" : "dart.async._StreamController"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "_AsyncStreamController" : 
        "name" : "_AsyncStreamController"
        "qualifiedname" : "dart.async._AsyncStreamController._AsyncStreamController"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "onListen" : 
            "name" : "onListen"
            "qualifiedname" : "dart.async._AsyncStreamController._AsyncStreamController#onListen"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onPause" : 
            "name" : "onPause"
            "qualifiedname" : "dart.async._AsyncStreamController._AsyncStreamController#onPause"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onResume" : 
            "name" : "onResume"
            "qualifiedname" : "dart.async._AsyncStreamController._AsyncStreamController#onResume"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onCancel" : 
            "name" : "onCancel"
            "qualifiedname" : "dart.async._AsyncStreamController._AsyncStreamController#onCancel"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_sendData" : 
        "name" : "_sendData"
        "qualifiedname" : "dart.async._AsyncStreamController._sendData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._AsyncStreamController._sendData#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._AsyncStreamController.T"
            "value" : "null"
      "_sendError" : 
        "name" : "_sendError"
        "qualifiedname" : "dart.async._AsyncStreamController._sendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._AsyncStreamController._sendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "_sendDone" : 
        "name" : "_sendDone"
        "qualifiedname" : "dart.async._AsyncStreamController._sendDone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_SyncStreamController" : 
    "name" : "_SyncStreamController"
    "qualifiedname" : "dart.async._SyncStreamController"
    "comment" : ""
    "superclass" : "dart.async._StreamController"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "_SyncStreamController" : 
        "name" : "_SyncStreamController"
        "qualifiedname" : "dart.async._SyncStreamController._SyncStreamController"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "onListen" : 
            "name" : "onListen"
            "qualifiedname" : "dart.async._SyncStreamController._SyncStreamController#onListen"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onPause" : 
            "name" : "onPause"
            "qualifiedname" : "dart.async._SyncStreamController._SyncStreamController#onPause"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onResume" : 
            "name" : "onResume"
            "qualifiedname" : "dart.async._SyncStreamController._SyncStreamController#onResume"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onCancel" : 
            "name" : "onCancel"
            "qualifiedname" : "dart.async._SyncStreamController._SyncStreamController#onCancel"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "_sendData" : 
        "name" : "_sendData"
        "qualifiedname" : "dart.async._SyncStreamController._sendData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._SyncStreamController._sendData#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._SyncStreamController.T"
            "value" : "null"
      "_sendError" : 
        "name" : "_sendError"
        "qualifiedname" : "dart.async._SyncStreamController._sendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._SyncStreamController._sendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "_sendDone" : 
        "name" : "_sendDone"
        "qualifiedname" : "dart.async._SyncStreamController._sendDone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_StreamController" : 
    "name" : "_StreamController"
    "qualifiedname" : "dart.async._StreamController"
    "comment" : "<p>Default implementation of <code>StreamController</code>.</p> <p>Controls a stream that only supports a single controller.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
      - "dart.async._EventDispatch"
      - "dart.async._StreamControllerLifecycle"
      - "dart.async.StreamController"
    "variables" : 
      "_STATE_OPEN" : 
        "name" : "_STATE_OPEN"
        "qualifiedname" : "dart.async._StreamController._STATE_OPEN"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_CANCELLED" : 
        "name" : "_STATE_CANCELLED"
        "qualifiedname" : "dart.async._StreamController._STATE_CANCELLED"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_STATE_CLOSED" : 
        "name" : "_STATE_CLOSED"
        "qualifiedname" : "dart.async._StreamController._STATE_CLOSED"
        "comment" : ""
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_onListen" : 
        "name" : "_onListen"
        "qualifiedname" : "dart.async._StreamController._onListen"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._NotificationHandler"
      "_onPause" : 
        "name" : "_onPause"
        "qualifiedname" : "dart.async._StreamController._onPause"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._NotificationHandler"
      "_onResume" : 
        "name" : "_onResume"
        "qualifiedname" : "dart.async._StreamController._onResume"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._NotificationHandler"
      "_onCancel" : 
        "name" : "_onCancel"
        "qualifiedname" : "dart.async._StreamController._onCancel"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._NotificationHandler"
      "_stream" : 
        "name" : "_stream"
        "qualifiedname" : "dart.async._StreamController._stream"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._StreamImpl"
      "_subscription" : 
        "name" : "_subscription"
        "qualifiedname" : "dart.async._StreamController._subscription"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._ControllerSubscription"
      "_state" : 
        "name" : "_state"
        "qualifiedname" : "dart.async._StreamController._state"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.int"
      "_pendingEvents" : 
        "name" : "_pendingEvents"
        "qualifiedname" : "dart.async._StreamController._pendingEvents"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._PendingEvents"
    "methods" : 
      "_StreamController" : 
        "name" : "_StreamController"
        "qualifiedname" : "dart.async._StreamController._StreamController"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_onListen" : 
            "name" : "_onListen"
            "qualifiedname" : "dart.async._StreamController._StreamController#_onListen"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._NotificationHandler"
            "value" : "null"
          "_onPause" : 
            "name" : "_onPause"
            "qualifiedname" : "dart.async._StreamController._StreamController#_onPause"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._NotificationHandler"
            "value" : "null"
          "_onResume" : 
            "name" : "_onResume"
            "qualifiedname" : "dart.async._StreamController._StreamController#_onResume"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._NotificationHandler"
            "value" : "null"
          "_onCancel" : 
            "name" : "_onCancel"
            "qualifiedname" : "dart.async._StreamController._StreamController#_onCancel"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._NotificationHandler"
            "value" : "null"
      "stream" : 
        "name" : "stream"
        "qualifiedname" : "dart.async._StreamController.stream"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
      "sink" : 
        "name" : "sink"
        "qualifiedname" : "dart.async._StreamController.sink"
        "comment" : "<p>Returns a view of this object that only exposes the <code>EventSink</code> interface.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async.EventSink"
        "parameters" : 
      "_isCancelled" : 
        "name" : "_isCancelled"
        "qualifiedname" : "dart.async._StreamController._isCancelled"
        "comment" : "<p>Whether a listener has existed and been cancelled.</p> <p>After this, adding more events will be ignored.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "isClosed" : 
        "name" : "isClosed"
        "qualifiedname" : "dart.async._StreamController.isClosed"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "isPaused" : 
        "name" : "isPaused"
        "qualifiedname" : "dart.async._StreamController.isPaused"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "hasListener" : 
        "name" : "hasListener"
        "qualifiedname" : "dart.async._StreamController.hasListener"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "add" : 
        "name" : "add"
        "qualifiedname" : "dart.async._StreamController.add"
        "comment" : "<p>Send or queue a data event.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._StreamController.add#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._StreamController.T"
            "value" : "null"
      "addError" : 
        "name" : "addError"
        "qualifiedname" : "dart.async._StreamController.addError"
        "comment" : "<p>Send or enqueue an error event.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._StreamController.addError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
          "stackTrace" : 
            "name" : "stackTrace"
            "qualifiedname" : "dart.async._StreamController.addError#stackTrace"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "close" : 
        "name" : "close"
        "qualifiedname" : "dart.async._StreamController.close"
        "comment" : "<p>Closes this controller.</p> <p>After closing, no further events may be added using <code>add</code> or <code>addError</code>.</p> <p>You are allowed to close the controller more than once, but only the first call has any effect.</p> <p>The first time a controller is closed, a \"done\" event is sent to its stream.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_addPendingEvent" : 
        "name" : "_addPendingEvent"
        "qualifiedname" : "dart.async._StreamController._addPendingEvent"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "event" : 
            "name" : "event"
            "qualifiedname" : "dart.async._StreamController._addPendingEvent#event"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._DelayedEvent"
            "value" : "null"
      "_recordListen" : 
        "name" : "_recordListen"
        "qualifiedname" : "dart.async._StreamController._recordListen"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._StreamController._recordListen#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._BufferingStreamSubscription"
            "value" : "null"
      "_recordCancel" : 
        "name" : "_recordCancel"
        "qualifiedname" : "dart.async._StreamController._recordCancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._StreamController._recordCancel#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamSubscription"
            "value" : "null"
      "_recordPause" : 
        "name" : "_recordPause"
        "qualifiedname" : "dart.async._StreamController._recordPause"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._StreamController._recordPause#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamSubscription"
            "value" : "null"
      "_recordResume" : 
        "name" : "_recordResume"
        "qualifiedname" : "dart.async._StreamController._recordResume"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._StreamController._recordResume#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamSubscription"
            "value" : "null"
  "_StreamControllerLifecycle" : 
    "name" : "_StreamControllerLifecycle"
    "qualifiedname" : "dart.async._StreamControllerLifecycle"
    "comment" : ""
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "_recordListen" : 
        "name" : "_recordListen"
        "qualifiedname" : "dart.async._StreamControllerLifecycle._recordListen"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._StreamControllerLifecycle._recordListen#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamSubscription"
            "value" : "null"
      "_recordPause" : 
        "name" : "_recordPause"
        "qualifiedname" : "dart.async._StreamControllerLifecycle._recordPause"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._StreamControllerLifecycle._recordPause#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamSubscription"
            "value" : "null"
      "_recordResume" : 
        "name" : "_recordResume"
        "qualifiedname" : "dart.async._StreamControllerLifecycle._recordResume"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._StreamControllerLifecycle._recordResume#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamSubscription"
            "value" : "null"
      "_recordCancel" : 
        "name" : "_recordCancel"
        "qualifiedname" : "dart.async._StreamControllerLifecycle._recordCancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "subscription" : 
            "name" : "subscription"
            "qualifiedname" : "dart.async._StreamControllerLifecycle._recordCancel#subscription"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamSubscription"
            "value" : "null"
  "StreamController" : 
    "name" : "StreamController"
    "qualifiedname" : "dart.async.StreamController"
    "comment" : "<p>A controller with the stream it controls.</p> <p>This controller allows sending data, error and done events on its <code>stream</code>. This class can be used to create a simple stream that others can listen on, and to push events to that stream.</p> <p>It's possible to check whether the stream is paused or not, and whether it has subscribers or not, as well as getting a callback when either of these change.</p> <p>If the stream starts or stops having listeners (first listener subscribing, last listener unsubscribing), the <code>onSubscriptionStateChange</code> callback is notified as soon as possible. If the subscription stat changes during an event firing or a callback being executed, the change will not be reported until the current event or callback has finished. If the pause state has also changed during an event or callback, only the subscription state callback is notified.</p> <p>If the subscriber state has not changed, but the pause state has, the <code>onPauseStateChange</code> callback is notified as soon as possible, after firing a current event or completing another callback. This happens if the stream is not paused, and a listener pauses it, or if the stream has been resumed from pause and has no pending events. If the listeners resume a paused stream while it still has queued events, the controller will still consider the stream paused until all queued events have been dispatched.</p> <p>Whether to invoke a callback depends only on the state before and after a stream action, for example firing an event. If the state changes multiple times during the action, and then ends up in the same state as before, no callback is performed.</p> <p>If listeners are added after the stream has completed (sent a \"done\" event), the listeners will be sent a \"done\" event eventually, but they won't affect the stream at all, and won't trigger callbacks. From the controller's point of view, the stream is completely inert when has completed.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
      - "dart.async.EventSink"
    "variables" : 
    "methods" : 
      "stream" : 
        "name" : "stream"
        "qualifiedname" : "dart.async.StreamController.stream"
        "comment" : "<p>The stream that this controller is controlling.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
      "StreamController" : 
        "name" : "StreamController"
        "qualifiedname" : "dart.async.StreamController.StreamController"
        "comment" : "<p>A controller with a <code>stream</code> that supports only one single subscriber.</p> <p>If <code>sync</code> is true, events may be passed directly to the stream's listener during an <code>add</code>, <code>addError</code> or <code>close</code> call. If <code>sync</code> is false, the event will be passed to the listener at a later time, after the code creating the event has returned.</p> <p>The controller will buffer all incoming events until the subscriber is registered.</p> <p>The <code>onPause</code> function is called when the stream becomes paused. <code>onResume</code> is called when the stream resumed.</p> <p>The <code>onListen</code> callback is called when the stream receives its listener and <code>onCancel</code> when the listener ends its subscription.</p> <p>If the stream is canceled before the controller needs new data the <code>onResume</code> call might not be executed.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.StreamController"
        "parameters" : 
          "onListen" : 
            "name" : "onListen"
            "qualifiedname" : "dart.async.StreamController.StreamController#onListen"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onPause" : 
            "name" : "onPause"
            "qualifiedname" : "dart.async.StreamController.StreamController#onPause"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onResume" : 
            "name" : "onResume"
            "qualifiedname" : "dart.async.StreamController.StreamController#onResume"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onCancel" : 
            "name" : "onCancel"
            "qualifiedname" : "dart.async.StreamController.StreamController#onCancel"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "sync" : 
            "name" : "sync"
            "qualifiedname" : "dart.async.StreamController.StreamController#sync"
            "optional" : "true"
            "named" : "true"
            "default" : "true"
            "type" : "dart.core.bool"
            "value" : "false"
      "StreamController.broadcast" : 
        "name" : "StreamController.broadcast"
        "qualifiedname" : "dart.async.StreamController.StreamController.broadcast"
        "comment" : "<p>A controller where <code>stream</code> can be listened to more than once.</p> <p>The <code>Stream</code> returned by <code>stream</code> is a broadcast stream. It can be listened to more than once.</p> <p>The controller distributes any events to all currently subscribed listeners. It is not allowed to call <code>add</code>, <code>addError</code>, or <code>close</code> before a previous call has returned.</p> <p>If <code>sync</code> is true, events may be passed directly to the stream's listener during an <code>add</code>, <code>addError</code> or <code>close</code> call. If <code>sync</code> is false, the event will be passed to the listener at a later time, after the code creating the event has returned.</p> <p>Each listener is handled independently, and if they pause, only the pausing listener is affected. A paused listener will buffer events internally until unpaused or canceled.</p> <p>If <code>sync</code> is false, no guarantees are given with regard to when multiple listeners get the events, except that each listener will get all events in the correct order. If two events are sent on an async controller with two listeners, one of the listeners may get both events before the other listener gets any. A listener must be subscribed both when the event is initiated (that is, when <code>add</code> is called) and when the event is later delivered, in order to get the event.</p> <p>The <code>onListen</code> callback is called when the first listener is subscribed, and the <code>onCancel</code> is called when there are no longer any active listeners. If a listener is added again later, after the <code>onCancel</code> was called, the <code>onListen</code> will be called again.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.StreamController"
        "parameters" : 
          "onListen" : 
            "name" : "onListen"
            "qualifiedname" : "dart.async.StreamController.StreamController.broadcast#onListen"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onCancel" : 
            "name" : "onCancel"
            "qualifiedname" : "dart.async.StreamController.StreamController.broadcast#onCancel"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "sync" : 
            "name" : "sync"
            "qualifiedname" : "dart.async.StreamController.StreamController.broadcast#sync"
            "optional" : "true"
            "named" : "true"
            "default" : "true"
            "type" : "dart.core.bool"
            "value" : "false"
      "sink" : 
        "name" : "sink"
        "qualifiedname" : "dart.async.StreamController.sink"
        "comment" : "<p>Returns a view of this object that only exposes the <code>EventSink</code> interface.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async.EventSink"
        "parameters" : 
      "isClosed" : 
        "name" : "isClosed"
        "qualifiedname" : "dart.async.StreamController.isClosed"
        "comment" : "<p>Whether the stream is closed for adding more events.</p> <p>If true, the \"done\" event might not have fired yet, but it has been scheduled, and it is too late to add more events.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "isPaused" : 
        "name" : "isPaused"
        "qualifiedname" : "dart.async.StreamController.isPaused"
        "comment" : "<p>Whether the subscription would need to buffer events.</p> <p>This is the case if the controller's stream has a listener and it is paused, or if it has not received a listener yet. In that case, the controller is considered paused as well.</p> <p>A broadcast stream controller is never considered paused. It always forwards its events to all uncanceled listeners, if any, and let them handle their own pausing.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "hasListener" : 
        "name" : "hasListener"
        "qualifiedname" : "dart.async.StreamController.hasListener"
        "comment" : "<p>Whether there is a subscriber on the <code>Stream</code>.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "addError" : 
        "name" : "addError"
        "qualifiedname" : "dart.async.StreamController.addError"
        "comment" : "<p>Send or enqueue an error event.</p> <p>Also allows an objection stack trace object, on top of what <code>EventSink</code> allows.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async.StreamController.addError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
          "stackTrace" : 
            "name" : "stackTrace"
            "qualifiedname" : "dart.async.StreamController.addError#stackTrace"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
  "StreamIterator" : 
    "name" : "StreamIterator"
    "qualifiedname" : "dart.async.StreamIterator"
    "comment" : "<p>An <code>Iterable</code> like interface for the values of a <code>Stream</code>.</p> <p>This wraps a <code>Stream</code> and a subscription on the stream. It listens on the stream, and completes the future returned by <code>moveNext</code> when the next value becomes available.</p> <p>NOTICE: This is a tentative design. This class may change.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "StreamIterator" : 
        "name" : "StreamIterator"
        "qualifiedname" : "dart.async.StreamIterator.StreamIterator"
        "comment" : "<p>Create a <code>StreamIterator</code> on <code>stream</code>.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.StreamIterator"
        "parameters" : 
          "stream" : 
            "name" : "stream"
            "qualifiedname" : "dart.async.StreamIterator.StreamIterator#stream"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
      "moveNext" : 
        "name" : "moveNext"
        "qualifiedname" : "dart.async.StreamIterator.moveNext"
        "comment" : "<p>Wait for the next stream value to be available.</p> <p>It is not allowed to call this function again until the future has completed. If the returned future completes with anything except <code>true</code>, the iterator is done, and no new value will ever be available.</p> <p>The future may complete with an error, if the stream produces an error.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
      "current" : 
        "name" : "current"
        "qualifiedname" : "dart.async.StreamIterator.current"
        "comment" : "<p>The current value of the stream.</p> <p>Only valid when the future returned by <code>moveNext</code> completes with <code>true</code> as value, and only until the next call to <code>moveNext</code>.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async.StreamIterator.T"
        "parameters" : 
      "cancel" : 
        "name" : "cancel"
        "qualifiedname" : "dart.async.StreamIterator.cancel"
        "comment" : "<p>Cancels the stream iterator (and the underlying stream subscription) early.</p> <p>The stream iterator is automatically canceled if the <code>moveNext</code> future completes with either <code>false</code> or an error.</p> <p>If a <code>moveNext</code> call has been made, it will complete with <code>false</code> as value, as will all further calls to <code>moveNext</code>.</p> <p>If you need to stop listening for values before the stream iterator is automatically closed, you must call <code>cancel</code> to ensure that the stream is properly closed.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_EventSinkAdapter" : 
    "name" : "_EventSinkAdapter"
    "qualifiedname" : "dart.async._EventSinkAdapter"
    "comment" : ""
    "superclass" : "dart.core.Object"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
      - "dart.async.EventSink"
    "variables" : 
      "_sink" : 
        "name" : "_sink"
        "qualifiedname" : "dart.async._EventSinkAdapter._sink"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._EventSink"
    "methods" : 
      "_EventSinkAdapter" : 
        "name" : "_EventSinkAdapter"
        "qualifiedname" : "dart.async._EventSinkAdapter._EventSinkAdapter"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_sink" : 
            "name" : "_sink"
            "qualifiedname" : "dart.async._EventSinkAdapter._EventSinkAdapter#_sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSink"
            "value" : "null"
      "add" : 
        "name" : "add"
        "qualifiedname" : "dart.async._EventSinkAdapter.add"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._EventSinkAdapter.add#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSinkAdapter.T"
            "value" : "null"
      "addError" : 
        "name" : "addError"
        "qualifiedname" : "dart.async._EventSinkAdapter.addError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._EventSinkAdapter.addError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "close" : 
        "name" : "close"
        "qualifiedname" : "dart.async._EventSinkAdapter.close"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "_EventTransformStreamSubscription" : 
    "name" : "_EventTransformStreamSubscription"
    "qualifiedname" : "dart.async._EventTransformStreamSubscription"
    "comment" : ""
    "superclass" : "dart.async._BufferingStreamSubscription"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_transformer" : 
        "name" : "_transformer"
        "qualifiedname" : "dart.async._EventTransformStreamSubscription._transformer"
        "comment" : "<p>The transformer used to transform events.</p>"
        "final" : "true"
        "static" : "false"
        "type" : "dart.async.StreamEventTransformer"
      "_isClosed" : 
        "name" : "_isClosed"
        "qualifiedname" : "dart.async._EventTransformStreamSubscription._isClosed"
        "comment" : "<p>Whether this stream has sent a done event.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.bool"
      "_subscription" : 
        "name" : "_subscription"
        "qualifiedname" : "dart.async._EventTransformStreamSubscription._subscription"
        "comment" : "<p>Source of incoming events.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dart.async.StreamSubscription"
      "_sink" : 
        "name" : "_sink"
        "qualifiedname" : "dart.async._EventTransformStreamSubscription._sink"
        "comment" : "<p>Cached EventSink wrapper for this class.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dart.async.EventSink"
    "methods" : 
      "_EventTransformStreamSubscription" : 
        "name" : "_EventTransformStreamSubscription"
        "qualifiedname" : "dart.async._EventTransformStreamSubscription._EventTransformStreamSubscription"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "source" : 
            "name" : "source"
            "qualifiedname" : "dart.async._EventTransformStreamSubscription._EventTransformStreamSubscription#source"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
          "_transformer" : 
            "name" : "_transformer"
            "qualifiedname" : "dart.async._EventTransformStreamSubscription._EventTransformStreamSubscription#_transformer"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamEventTransformer"
            "value" : "null"
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async._EventTransformStreamSubscription._EventTransformStreamSubscription#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async._EventTransformStreamSubscription._EventTransformStreamSubscription#onError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async._EventTransformStreamSubscription._EventTransformStreamSubscription#onDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async._EventTransformStreamSubscription._EventTransformStreamSubscription#cancelOnError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
      "_isSubscribed" : 
        "name" : "_isSubscribed"
        "qualifiedname" : "dart.async._EventTransformStreamSubscription._isSubscribed"
        "comment" : "<p>Whether this subscription is still subscribed to its source.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_onPause" : 
        "name" : "_onPause"
        "qualifiedname" : "dart.async._EventTransformStreamSubscription._onPause"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_onResume" : 
        "name" : "_onResume"
        "qualifiedname" : "dart.async._EventTransformStreamSubscription._onResume"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_onCancel" : 
        "name" : "_onCancel"
        "qualifiedname" : "dart.async._EventTransformStreamSubscription._onCancel"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_handleData" : 
        "name" : "_handleData"
        "qualifiedname" : "dart.async._EventTransformStreamSubscription._handleData"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async._EventTransformStreamSubscription._handleData#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventTransformStreamSubscription.S"
            "value" : "null"
      "_handleError" : 
        "name" : "_handleError"
        "qualifiedname" : "dart.async._EventTransformStreamSubscription._handleError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._EventTransformStreamSubscription._handleError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "_handleDone" : 
        "name" : "_handleDone"
        "qualifiedname" : "dart.async._EventTransformStreamSubscription._handleDone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "EventTransformStream" : 
    "name" : "EventTransformStream"
    "qualifiedname" : "dart.async.EventTransformStream"
    "comment" : "<p>Stream that transforms another stream by intercepting and replacing events.</p> <p>This <code>Stream</code> is a transformation of a source stream. Listening on this stream is the same as listening on the source stream, except that events are intercepted and modified by a <code>StreamEventTransformer</code> before becoming events on this stream.</p>"
    "superclass" : "dart.async.Stream"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_source" : 
        "name" : "_source"
        "qualifiedname" : "dart.async.EventTransformStream._source"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async.Stream"
      "_transformer" : 
        "name" : "_transformer"
        "qualifiedname" : "dart.async.EventTransformStream._transformer"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async.StreamEventTransformer"
    "methods" : 
      "EventTransformStream" : 
        "name" : "EventTransformStream"
        "qualifiedname" : "dart.async.EventTransformStream.EventTransformStream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "source" : 
            "name" : "source"
            "qualifiedname" : "dart.async.EventTransformStream.EventTransformStream#source"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
          "transformer" : 
            "name" : "transformer"
            "qualifiedname" : "dart.async.EventTransformStream.EventTransformStream#transformer"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamEventTransformer"
            "value" : "null"
      "listen" : 
        "name" : "listen"
        "qualifiedname" : "dart.async.EventTransformStream.listen"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.StreamSubscription"
        "parameters" : 
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async.EventTransformStream.listen#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async.EventTransformStream.listen#onError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async.EventTransformStream.listen#onDone"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async.EventTransformStream.listen#cancelOnError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
  "StreamEventTransformer" : 
    "name" : "StreamEventTransformer"
    "qualifiedname" : "dart.async.StreamEventTransformer"
    "comment" : "<p>Base class for transformers that modifies stream events.</p> <p>A <code>StreamEventTransformer</code> transforms incoming Stream events of one kind into outgoing events of (possibly) another kind.</p> <p>Subscribing on the stream returned by <code>bind</code> is the same as subscribing on the source stream, except that events are passed through the <code>transformer</code> before being emitted. The transformer may generate any number and types of events for each incoming event. Pauses on the returned subscription are forwarded to this stream.</p> <p>An example that duplicates all data events:</p> <pre><code>class DoubleTransformer&lt;T&gt; extends StreamEventTransformer&lt;T, T&gt; {   void handleData(T data, EventSink&lt;T&gt; sink) {     sink.add(value);     sink.add(value);   } } someTypeStream.transform(new DoubleTransformer&lt;Type&gt;()); </code></pre> <p>The default implementations of the \"handle\" methods forward the events unmodified. If using the default <code>handleData</code> the generic type <code>T</code> needs to be assignable to <code>S</code>.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
      - "dart.async.StreamTransformer"
    "variables" : 
    "methods" : 
      "StreamEventTransformer" : 
        "name" : "StreamEventTransformer"
        "qualifiedname" : "dart.async.StreamEventTransformer.StreamEventTransformer"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
      "bind" : 
        "name" : "bind"
        "qualifiedname" : "dart.async.StreamEventTransformer.bind"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "source" : 
            "name" : "source"
            "qualifiedname" : "dart.async.StreamEventTransformer.bind#source"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
      "handleData" : 
        "name" : "handleData"
        "qualifiedname" : "dart.async.StreamEventTransformer.handleData"
        "comment" : "<p>Act on incoming data event.</p> <p>The method may generate any number of events on the sink, but should not throw.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "event" : 
            "name" : "event"
            "qualifiedname" : "dart.async.StreamEventTransformer.handleData#event"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamEventTransformer.S"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async.StreamEventTransformer.handleData#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.EventSink"
            "value" : "null"
      "handleError" : 
        "name" : "handleError"
        "qualifiedname" : "dart.async.StreamEventTransformer.handleError"
        "comment" : "<p>Act on incoming error event.</p> <p>The method may generate any number of events on the sink, but should not throw.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async.StreamEventTransformer.handleError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async.StreamEventTransformer.handleError#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.EventSink"
            "value" : "null"
      "handleDone" : 
        "name" : "handleDone"
        "qualifiedname" : "dart.async.StreamEventTransformer.handleDone"
        "comment" : "<p>Act on incoming done event.</p> <p>The method may generate any number of events on the sink, but should not throw.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "sink" : 
            "name" : "sink"
            "qualifiedname" : "dart.async.StreamEventTransformer.handleDone#sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.EventSink"
            "value" : "null"
  "StreamTransformer" : 
    "name" : "StreamTransformer"
    "qualifiedname" : "dart.async.StreamTransformer"
    "comment" : "<p>The target of a <code>Stream.transform</code> call.</p> <p>The <code>Stream.transform</code> call will pass itself to this object and then return the resulting stream.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "StreamTransformer" : 
        "name" : "StreamTransformer"
        "qualifiedname" : "dart.async.StreamTransformer.StreamTransformer"
        "comment" : "<p>Create a <code>StreamTransformer</code> that delegates events to the given functions.</p> <p>This is actually a <code>StreamEventTransformer</code> where the event handling is performed by the function arguments. If an argument is omitted, it acts as the corresponding default method from <code>StreamEventTransformer</code>.</p> <p>Example use:</p> <pre><code>stringStream.transform(new StreamTransformer&lt;String, String&gt;(     handleData: (Strung value, EventSink&lt;String&gt; sink) {       sink.add(value);       sink.add(value);  // Duplicate the incoming events.     })); </code></pre>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.StreamTransformer"
        "parameters" : 
          "handleData" : 
            "name" : "handleData"
            "qualifiedname" : "dart.async.StreamTransformer.StreamTransformer#handleData"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "handleError" : 
            "name" : "handleError"
            "qualifiedname" : "dart.async.StreamTransformer.StreamTransformer#handleError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "handleDone" : 
            "name" : "handleDone"
            "qualifiedname" : "dart.async.StreamTransformer.StreamTransformer#handleDone"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "bind" : 
        "name" : "bind"
        "qualifiedname" : "dart.async.StreamTransformer.bind"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "stream" : 
            "name" : "stream"
            "qualifiedname" : "dart.async.StreamTransformer.bind#stream"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
  "StreamSink" : 
    "name" : "StreamSink"
    "qualifiedname" : "dart.async.StreamSink"
    "comment" : "<p>A <code>StreamSink</code> unifies the asynchronous methods from <code>StreamConsumer</code> and the synchronous methods from <code>EventSink</code>.</p> <p>The <code>EventSink</code> methods can't be used while the <code>addStream</code> is called. As soon as the <code>addStream</code>'s <code>Future</code> completes with a value, the <code>EventSink</code> methods can be used again.</p> <p>If <code>addStream</code> is called after any of the <code>EventSink</code> methods, it'll be delayed until the underlying system has consumed the data added by the <code>EventSink</code> methods.</p> <p>When <code>EventSink</code> methods are used, the [done] [Future] can be used to catch any errors.</p> <p>When <code>close</code> is called, it will return the [done] [Future].</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
      - "dart.async.EventSink"
      - "dart.async.StreamConsumer"
    "variables" : 
    "methods" : 
      "close" : 
        "name" : "close"
        "qualifiedname" : "dart.async.StreamSink.close"
        "comment" : "<p>Close the <code>StreamSink</code>. It'll return the <code>done</code> Future.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
      "done" : 
        "name" : "done"
        "qualifiedname" : "dart.async.StreamSink.done"
        "comment" : "<p>The <code>done</code> Future completes with the same values as <code>close</code>, except for the following case:</p><ul><li> <p>The synchronous methods of <code>EventSink</code> were called, resulting in an   error. If there is no active future (like from an addStream call), the   <code>done</code> future will complete with that error</p></li></ul>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
  "StreamConsumer" : 
    "name" : "StreamConsumer"
    "qualifiedname" : "dart.async.StreamConsumer"
    "comment" : "<p>The target of a <code>Stream.pipe</code> call.</p> <p>The <code>Stream.pipe</code> call will pass itself to this object, and then return the resulting <code>Future</code>. The pipe should complete the future when it's done.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "addStream" : 
        "name" : "addStream"
        "qualifiedname" : "dart.async.StreamConsumer.addStream"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "stream" : 
            "name" : "stream"
            "qualifiedname" : "dart.async.StreamConsumer.addStream#stream"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
      "close" : 
        "name" : "close"
        "qualifiedname" : "dart.async.StreamConsumer.close"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
  "_EventSinkView" : 
    "name" : "_EventSinkView"
    "qualifiedname" : "dart.async._EventSinkView"
    "comment" : "<p><code>EventSink</code> wrapper that only exposes the <code>EventSink</code> interface.</p>"
    "superclass" : "dart.async.EventSink"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_sink" : 
        "name" : "_sink"
        "qualifiedname" : "dart.async._EventSinkView._sink"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async.EventSink"
    "methods" : 
      "_EventSinkView" : 
        "name" : "_EventSinkView"
        "qualifiedname" : "dart.async._EventSinkView._EventSinkView"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_sink" : 
            "name" : "_sink"
            "qualifiedname" : "dart.async._EventSinkView._EventSinkView#_sink"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.EventSink"
            "value" : "null"
      "add" : 
        "name" : "add"
        "qualifiedname" : "dart.async._EventSinkView.add"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._EventSinkView.add#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._EventSinkView.T"
            "value" : "null"
      "addError" : 
        "name" : "addError"
        "qualifiedname" : "dart.async._EventSinkView.addError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._EventSinkView.addError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "close" : 
        "name" : "close"
        "qualifiedname" : "dart.async._EventSinkView.close"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "StreamView" : 
    "name" : "StreamView"
    "qualifiedname" : "dart.async.StreamView"
    "comment" : "<p><code>Stream</code> wrapper that only exposes the <code>Stream</code> interface.</p>"
    "superclass" : "dart.async.Stream"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_stream" : 
        "name" : "_stream"
        "qualifiedname" : "dart.async.StreamView._stream"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async.Stream"
    "methods" : 
      "StreamView" : 
        "name" : "StreamView"
        "qualifiedname" : "dart.async.StreamView.StreamView"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_stream" : 
            "name" : "_stream"
            "qualifiedname" : "dart.async.StreamView.StreamView#_stream"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Stream"
            "value" : "null"
      "isBroadcast" : 
        "name" : "isBroadcast"
        "qualifiedname" : "dart.async.StreamView.isBroadcast"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "asBroadcastStream" : 
        "name" : "asBroadcastStream"
        "qualifiedname" : "dart.async.StreamView.asBroadcastStream"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
      "listen" : 
        "name" : "listen"
        "qualifiedname" : "dart.async.StreamView.listen"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.StreamSubscription"
        "parameters" : 
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async.StreamView.listen#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async.StreamView.listen#onError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async.StreamView.listen#onDone"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async.StreamView.listen#cancelOnError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
  "EventSink" : 
    "name" : "EventSink"
    "qualifiedname" : "dart.async.EventSink"
    "comment" : "<p>An interface that abstracts creation or handling of <code>Stream</code> events.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "add" : 
        "name" : "add"
        "qualifiedname" : "dart.async.EventSink.add"
        "comment" : "<p>Create a data event</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "event" : 
            "name" : "event"
            "qualifiedname" : "dart.async.EventSink.add#event"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.EventSink.T"
            "value" : "null"
      "addError" : 
        "name" : "addError"
        "qualifiedname" : "dart.async.EventSink.addError"
        "comment" : "<p>Create an async error.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "errorEvent" : 
            "name" : "errorEvent"
            "qualifiedname" : "dart.async.EventSink.addError#errorEvent"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "close" : 
        "name" : "close"
        "qualifiedname" : "dart.async.EventSink.close"
        "comment" : "<p>Request a stream to close.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
  "StreamSubscription" : 
    "name" : "StreamSubscription"
    "qualifiedname" : "dart.async.StreamSubscription"
    "comment" : "<p>A control object for the subscription on a <code>Stream</code>.</p> <p>When you subscribe on a <code>Stream</code> using <code>Stream.listen</code>, a <code>StreamSubscription</code> object is returned. This object is used to later unsubscribe again, or to temporarily pause the stream's events.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "cancel" : 
        "name" : "cancel"
        "qualifiedname" : "dart.async.StreamSubscription.cancel"
        "comment" : "<p>Cancels this subscription. It will no longer receive events.</p> <p>If an event is currently firing, this unsubscription will only take effect after all subscribers have received the current event.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "onData" : 
        "name" : "onData"
        "qualifiedname" : "dart.async.StreamSubscription.onData"
        "comment" : "<p>Set or override the data event handler of this subscription.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "handleData" : 
            "name" : "handleData"
            "qualifiedname" : "dart.async.StreamSubscription.onData#handleData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "onError" : 
        "name" : "onError"
        "qualifiedname" : "dart.async.StreamSubscription.onError"
        "comment" : "<p>Set or override the error event handler of this subscription.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "handleError" : 
            "name" : "handleError"
            "qualifiedname" : "dart.async.StreamSubscription.onError#handleError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "onDone" : 
        "name" : "onDone"
        "qualifiedname" : "dart.async.StreamSubscription.onDone"
        "comment" : "<p>Set or override the done event handler of this subscription.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "handleDone" : 
            "name" : "handleDone"
            "qualifiedname" : "dart.async.StreamSubscription.onDone#handleDone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "pause" : 
        "name" : "pause"
        "qualifiedname" : "dart.async.StreamSubscription.pause"
        "comment" : "<p>Request that the stream pauses events until further notice.</p> <p>If <code>resumeSignal</code> is provided, the stream will undo the pause when the future completes. If the future completes with an error, it will not be handled!</p> <p>A call to <code>resume</code> will also undo a pause.</p> <p>If the subscription is paused more than once, an equal number of resumes must be performed to resume the stream.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "resumeSignal" : 
            "name" : "resumeSignal"
            "qualifiedname" : "dart.async.StreamSubscription.pause#resumeSignal"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Future"
            "value" : "null"
      "resume" : 
        "name" : "resume"
        "qualifiedname" : "dart.async.StreamSubscription.resume"
        "comment" : "<p>Resume after a pause.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "isPaused" : 
        "name" : "isPaused"
        "qualifiedname" : "dart.async.StreamSubscription.isPaused"
        "comment" : "<p>Returns true if the <code>StreamSubscription</code> is paused.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "asFuture" : 
        "name" : "asFuture"
        "qualifiedname" : "dart.async.StreamSubscription.asFuture"
        "comment" : "<p>Returns a future that handles the <code>onDone</code> and <code>onError</code> callbacks.</p> <p>This method <em>overwrites</em> the existing <code>onDone</code> and <code>onError</code> callbacks with new ones that complete the returned future.</p> <p>In case of an error the subscription will automatically cancel (even when it was listening with <code>cancelOnError</code> set to <code>false</code>).</p> <p>In case of a <code>done</code> event the future completes with the given <code>futureValue</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "futureValue" : 
            "name" : "futureValue"
            "qualifiedname" : "dart.async.StreamSubscription.asFuture#futureValue"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
  "Stream" : 
    "name" : "Stream"
    "qualifiedname" : "dart.async.Stream"
    "comment" : "<p>A source of asynchronous data events.</p> <p>A Stream provides a sequence of events. Each event is either a data event or an error event, representing the result of a single computation. When the Stream is exhausted, it may send a single \"done\" event.</p> <p>You can <code>listen</code> on a stream to receive the events it sends. When you listen, you receive a <code>StreamSubscription</code> object that can be used to stop listening, or to temporarily pause events from the stream.</p> <p>When an event is fired, the listeners at that time are informed. If a listener is added while an event is being fired, the change will only take effect after the event is completely fired. If a listener is canceled, it immediately stops receiving events.</p> <p>When the \"done\" event is fired, subscribers are unsubscribed before receiving the event. After the event has been sent, the stream has no subscribers. Adding new subscribers after this point is allowed, but they will just receive a new \"done\" event as soon as possible.</p> <p>Streams always respect \"pause\" requests. If necessary they need to buffer their input, but often, and preferably, they can simply request their input to pause too.</p> <p>There are two kinds of streams: The normal \"single-subscription\" streams and \"broadcast\" streams.</p> <p>A single-subscription stream allows only a single listener at a time. It holds back events until it gets a listener, and it may exhaust itself when the listener is unsubscribed, even if the stream wasn't done.</p> <p>Single-subscription streams are generally used for streaming parts of contiguous data like file I/O.</p> <p>A broadcast stream allows any number of listeners, and it fires its events when they are ready, whether there are listeners or not.</p> <p>Broadcast streams are used for independent events/observers.</p> <p>The default implementation of <code>isBroadcast</code> returns false. A broadcast stream inheriting from <code>Stream</code> must override <code>isBroadcast</code> to return <code>:true:</code>.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "Stream" : 
        "name" : "Stream"
        "qualifiedname" : "dart.async.Stream.Stream"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
      "Stream.fromFuture" : 
        "name" : "Stream.fromFuture"
        "qualifiedname" : "dart.async.Stream.Stream.fromFuture"
        "comment" : "<p>Creates a new single-subscription stream from the future.</p> <p>When the future completes, the stream will fire one event, either data or error, and then close with a done-event.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "future" : 
            "name" : "future"
            "qualifiedname" : "dart.async.Stream.Stream.fromFuture#future"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Future"
            "value" : "null"
      "Stream.fromIterable" : 
        "name" : "Stream.fromIterable"
        "qualifiedname" : "dart.async.Stream.Stream.fromIterable"
        "comment" : "<p>Creates a single-subscription stream that gets its data from <code>data</code>.</p> <p>If iterating <code>data</code> throws an error, the stream ends immediately with that error. No done event will be sent (iteration is not complete), but no further data events will be generated either, since iteration cannot continue.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "data" : 
            "name" : "data"
            "qualifiedname" : "dart.async.Stream.Stream.fromIterable#data"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Iterable"
            "value" : "null"
      "Stream.periodic" : 
        "name" : "Stream.periodic"
        "qualifiedname" : "dart.async.Stream.Stream.periodic"
        "comment" : "<p>Creates a stream that repeatedly emits events at <code>period</code> intervals.</p> <p>The event values are computed by invoking <code>computation</code>. The argument to this callback is an integer that starts with 0 and is incremented for every event.</p> <p>If <code>computation</code> is omitted the event values will all be <code>null</code>.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "period" : 
            "name" : "period"
            "qualifiedname" : "dart.async.Stream.Stream.periodic#period"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Duration"
            "value" : "null"
          "computation" : 
            "name" : "computation"
            "qualifiedname" : "dart.async.Stream.Stream.periodic#computation"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "isBroadcast" : 
        "name" : "isBroadcast"
        "qualifiedname" : "dart.async.Stream.isBroadcast"
        "comment" : "<p>Reports whether this stream is a broadcast stream.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "asBroadcastStream" : 
        "name" : "asBroadcastStream"
        "qualifiedname" : "dart.async.Stream.asBroadcastStream"
        "comment" : "<p>Returns a multi-subscription stream that produces the same events as this.</p> <p>If this stream is single-subscription, return a new stream that allows multiple subscribers. It will subscribe to this stream when its first subscriber is added, and unsubscribe again when the last subscription is canceled.</p> <p>If this stream is already a broadcast stream, it is returned unmodified.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
      "listen" : 
        "name" : "listen"
        "qualifiedname" : "dart.async.Stream.listen"
        "comment" : "<p>Adds a subscription to this stream.</p> <p>On each data event from this stream, the subscriber's <code>onData</code> handler is called. If <code>onData</code> is null, nothing happens.</p> <p>On errors from this stream, the <code>onError</code> handler is given a object describing the error.</p> <p>If this stream closes, the <code>onDone</code> handler is called.</p> <p>If <code>cancelOnError</code> is true, the subscription is ended when the first error is reported. The default is false.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.StreamSubscription"
        "parameters" : 
          "onData" : 
            "name" : "onData"
            "qualifiedname" : "dart.async.Stream.listen#onData"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async.Stream.listen#onError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onDone" : 
            "name" : "onDone"
            "qualifiedname" : "dart.async.Stream.listen#onDone"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "cancelOnError" : 
            "name" : "cancelOnError"
            "qualifiedname" : "dart.async.Stream.listen#cancelOnError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.bool"
            "value" : "null"
      "where" : 
        "name" : "where"
        "qualifiedname" : "dart.async.Stream.where"
        "comment" : "<p>Creates a new stream from this stream that discards some data events.</p> <p>The new stream sends the same error and done events as this stream, but it only sends the data events that satisfy the <code>test</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async.Stream.where#test"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "map" : 
        "name" : "map"
        "qualifiedname" : "dart.async.Stream.map"
        "comment" : "<p>Creates a new stream that converts each element of this stream to a new value using the <code>convert</code> function.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "convert" : 
            "name" : "convert"
            "qualifiedname" : "dart.async.Stream.map#convert"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "handleError" : 
        "name" : "handleError"
        "qualifiedname" : "dart.async.Stream.handleError"
        "comment" : "<p>Creates a wrapper Stream that intercepts some errors from this stream.</p> <p>If this stream sends an error that matches <code>test</code>, then it is intercepted by the <code>handle</code> function.</p> <p>An [AsyncError] [:e:] is matched by a test function if <code>:test(e):</code> returns true. If <code>test</code> is omitted, every error is considered matching.</p> <p>If the error is intercepted, the <code>handle</code> function can decide what to do with it. It can throw if it wants to raise a new (or the same) error, or simply return to make the stream forget the error.</p> <p>If you need to transform an error into a data event, use the more generic <code>Stream.transformEvent</code> to handle the event by writing a data event to the output sink</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "handle" : 
            "name" : "handle"
            "qualifiedname" : "dart.async.Stream.handleError#handle"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async.Stream.handleError#test"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "expand" : 
        "name" : "expand"
        "qualifiedname" : "dart.async.Stream.expand"
        "comment" : "<p>Creates a new stream from this stream that converts each element into zero or more events.</p> <p>Each incoming event is converted to an <code>Iterable</code> of new events, and each of these new events are then sent by the returned stream in order.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "convert" : 
            "name" : "convert"
            "qualifiedname" : "dart.async.Stream.expand#convert"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "pipe" : 
        "name" : "pipe"
        "qualifiedname" : "dart.async.Stream.pipe"
        "comment" : "<p>Binds this stream as the input of the provided <code>StreamConsumer</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "streamConsumer" : 
            "name" : "streamConsumer"
            "qualifiedname" : "dart.async.Stream.pipe#streamConsumer"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamConsumer"
            "value" : "null"
      "transform" : 
        "name" : "transform"
        "qualifiedname" : "dart.async.Stream.transform"
        "comment" : "<p>Chains this stream as the input of the provided <code>StreamTransformer</code>.</p> <p>Returns the result of <code>:streamTransformer.bind:</code> itself.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "streamTransformer" : 
            "name" : "streamTransformer"
            "qualifiedname" : "dart.async.Stream.transform#streamTransformer"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.StreamTransformer"
            "value" : "null"
      "reduce" : 
        "name" : "reduce"
        "qualifiedname" : "dart.async.Stream.reduce"
        "comment" : "<p>Reduces a sequence of values by repeatedly applying <code>combine</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "combine" : 
            "name" : "combine"
            "qualifiedname" : "dart.async.Stream.reduce#combine"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "fold" : 
        "name" : "fold"
        "qualifiedname" : "dart.async.Stream.fold"
        "comment" : "<p>Reduces a sequence of values by repeatedly applying <code>combine</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "initialValue" : 
            "name" : "initialValue"
            "qualifiedname" : "dart.async.Stream.fold#initialValue"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
          "combine" : 
            "name" : "combine"
            "qualifiedname" : "dart.async.Stream.fold#combine"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "contains" : 
        "name" : "contains"
        "qualifiedname" : "dart.async.Stream.contains"
        "comment" : "<p>Checks whether <code>needle</code> occurs in the elements provided by this stream.</p> <p>Completes the <code>Future</code> when the answer is known. If this stream reports an error, the <code>Future</code> will report that error.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "needle" : 
            "name" : "needle"
            "qualifiedname" : "dart.async.Stream.contains#needle"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "forEach" : 
        "name" : "forEach"
        "qualifiedname" : "dart.async.Stream.forEach"
        "comment" : "<p>Executes <code>action</code> on each data event of the stream.</p> <p>Completes the returned <code>Future</code> when all events of the stream have been processed. Completes the future with an error if the stream has an error event, or if <code>action</code> throws.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "action" : 
            "name" : "action"
            "qualifiedname" : "dart.async.Stream.forEach#action"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "every" : 
        "name" : "every"
        "qualifiedname" : "dart.async.Stream.every"
        "comment" : "<p>Checks whether <code>test</code> accepts all elements provided by this stream.</p> <p>Completes the <code>Future</code> when the answer is known. If this stream reports an error, the <code>Future</code> will report that error.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async.Stream.every#test"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "any" : 
        "name" : "any"
        "qualifiedname" : "dart.async.Stream.any"
        "comment" : "<p>Checks whether <code>test</code> accepts any element provided by this stream.</p> <p>Completes the <code>Future</code> when the answer is known. If this stream reports an error, the <code>Future</code> will report that error.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async.Stream.any#test"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "length" : 
        "name" : "length"
        "qualifiedname" : "dart.async.Stream.length"
        "comment" : "<p>Counts the elements in the stream.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
      "isEmpty" : 
        "name" : "isEmpty"
        "qualifiedname" : "dart.async.Stream.isEmpty"
        "comment" : "<p>Reports whether this stream contains any elements.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
      "toList" : 
        "name" : "toList"
        "qualifiedname" : "dart.async.Stream.toList"
        "comment" : "<p>Collects the data of this stream in a <code>List</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
      "toSet" : 
        "name" : "toSet"
        "qualifiedname" : "dart.async.Stream.toSet"
        "comment" : "<p>Collects the data of this stream in a <code>Set</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
      "drain" : 
        "name" : "drain"
        "qualifiedname" : "dart.async.Stream.drain"
        "comment" : "<p>Discards all data on the stream, but signals when it's done or an error occured.</p> <p>When subscribing using <code>drain</code>, cancelOnError will be true. This means that the future will complete with the first error on the stream and then cancel the subscription.</p> <p>In case of a <code>done</code> event the future completes with the given <code>futureValue</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "futureValue" : 
            "name" : "futureValue"
            "qualifiedname" : "dart.async.Stream.drain#futureValue"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "take" : 
        "name" : "take"
        "qualifiedname" : "dart.async.Stream.take"
        "comment" : "<p>Provides at most the first <code>n</code> values of this stream.</p> <p>Forwards the first <code>n</code> data events of this stream, and all error events, to the returned stream, and ends with a done event.</p> <p>If this stream produces fewer than <code>count</code> values before it's done, so will the returned stream.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "count" : 
            "name" : "count"
            "qualifiedname" : "dart.async.Stream.take#count"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.int"
            "value" : "null"
      "takeWhile" : 
        "name" : "takeWhile"
        "qualifiedname" : "dart.async.Stream.takeWhile"
        "comment" : "<p>Forwards data events while <code>test</code> is successful.</p> <p>The returned stream provides the same events as this stream as long as <code>test</code> returns <code>:true:</code> for the event data. The stream is done when either this stream is done, or when this stream first provides a value that <code>test</code> doesn't accept.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async.Stream.takeWhile#test"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "skip" : 
        "name" : "skip"
        "qualifiedname" : "dart.async.Stream.skip"
        "comment" : "<p>Skips the first <code>count</code> data events from this stream.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "count" : 
            "name" : "count"
            "qualifiedname" : "dart.async.Stream.skip#count"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.int"
            "value" : "null"
      "skipWhile" : 
        "name" : "skipWhile"
        "qualifiedname" : "dart.async.Stream.skipWhile"
        "comment" : "<p>Skip data events from this stream while they are matched by <code>test</code>.</p> <p>Error and done events are provided by the returned stream unmodified.</p> <p>Starting with the first data event where <code>test</code> returns true for the event data, the returned stream will have the same events as this stream.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async.Stream.skipWhile#test"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "distinct" : 
        "name" : "distinct"
        "qualifiedname" : "dart.async.Stream.distinct"
        "comment" : "<p>Skips data events if they are equal to the previous data event.</p> <p>The returned stream provides the same events as this stream, except that it never provides two consequtive data events that are equal.</p> <p>Equality is determined by the provided <code>equals</code> method. If that is omitted, the '==' operator on the last provided data element is used.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
          "equals" : 
            "name" : "equals"
            "qualifiedname" : "dart.async.Stream.distinct#equals"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "first" : 
        "name" : "first"
        "qualifiedname" : "dart.async.Stream.first"
        "comment" : "<p>Returns the first element.</p> <p>If <code>this</code> is empty throws a <code>StateError</code>. Otherwise this method is equivalent to <code>:this.elementAt(0):</code></p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
      "last" : 
        "name" : "last"
        "qualifiedname" : "dart.async.Stream.last"
        "comment" : "<p>Returns the last element.</p> <p>If <code>this</code> is empty throws a <code>StateError</code>.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
      "single" : 
        "name" : "single"
        "qualifiedname" : "dart.async.Stream.single"
        "comment" : "<p>Returns the single element.</p> <p>If <code>this</code> is empty or has more than one element throws a <code>StateError</code>.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
      "firstWhere" : 
        "name" : "firstWhere"
        "qualifiedname" : "dart.async.Stream.firstWhere"
        "comment" : "<p>Finds the first element of this stream matching <code>test</code>.</p> <p>Returns a future that is filled with the first element of this stream that <code>test</code> returns true for.</p> <p>If no such element is found before this stream is done, and a <code>defaultValue</code> function is provided, the result of calling <code>defaultValue</code> becomes the value of the future.</p> <p>If an error occurs, or if this stream ends without finding a match and with no <code>defaultValue</code> function provided, the future will receive an error.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async.Stream.firstWhere#test"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "defaultValue" : 
            "name" : "defaultValue"
            "qualifiedname" : "dart.async.Stream.firstWhere#defaultValue"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "lastWhere" : 
        "name" : "lastWhere"
        "qualifiedname" : "dart.async.Stream.lastWhere"
        "comment" : "<p>Finds the last element in this stream matching <code>test</code>.</p> <p>As <code>firstWhere</code>, except that the last matching element is found. That means that the result cannot be provided before this stream is done.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async.Stream.lastWhere#test"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "defaultValue" : 
            "name" : "defaultValue"
            "qualifiedname" : "dart.async.Stream.lastWhere#defaultValue"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "singleWhere" : 
        "name" : "singleWhere"
        "qualifiedname" : "dart.async.Stream.singleWhere"
        "comment" : "<p>Finds the single element in this stream matching <code>test</code>.</p> <p>Like <code>lastMatch</code>, except that it is an error if more than one matching element occurs in the stream.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async.Stream.singleWhere#test"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "elementAt" : 
        "name" : "elementAt"
        "qualifiedname" : "dart.async.Stream.elementAt"
        "comment" : "<p>Returns the value of the <code>index</code>th data event of this stream.</p> <p>If an error event occurs, the future will end with this error.</p> <p>If this stream provides fewer than <code>index</code> elements before closing, an error is reported.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "index" : 
            "name" : "index"
            "qualifiedname" : "dart.async.Stream.elementAt#index"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.int"
            "value" : "null"
  "_WhenFuture" : 
    "name" : "_WhenFuture"
    "qualifiedname" : "dart.async._WhenFuture"
    "comment" : "<p>Future returned by <code>Future.whenComplete</code>.</p>"
    "superclass" : "dart.async._TransformFuture"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_action" : 
        "name" : "_action"
        "qualifiedname" : "dart.async._WhenFuture._action"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._FutureAction"
    "methods" : 
      "_WhenFuture" : 
        "name" : "_WhenFuture"
        "qualifiedname" : "dart.async._WhenFuture._WhenFuture"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_action" : 
            "name" : "_action"
            "qualifiedname" : "dart.async._WhenFuture._WhenFuture#_action"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureAction"
            "value" : "null"
      "_zonedSendValue" : 
        "name" : "_zonedSendValue"
        "qualifiedname" : "dart.async._WhenFuture._zonedSendValue"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._WhenFuture._zonedSendValue#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._WhenFuture.T"
            "value" : "null"
      "_zonedSendError" : 
        "name" : "_zonedSendError"
        "qualifiedname" : "dart.async._WhenFuture._zonedSendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._WhenFuture._zonedSendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
  "_SubscribeFuture" : 
    "name" : "_SubscribeFuture"
    "qualifiedname" : "dart.async._SubscribeFuture"
    "comment" : "<p>Future returned by <code>Future.then</code> with an <code>:onError:</code> parameter.</p>"
    "superclass" : "dart.async._ThenFuture"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_onError" : 
        "name" : "_onError"
        "qualifiedname" : "dart.async._SubscribeFuture._onError"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._FutureOnError"
    "methods" : 
      "_SubscribeFuture" : 
        "name" : "_SubscribeFuture"
        "qualifiedname" : "dart.async._SubscribeFuture._SubscribeFuture"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "onValue" : 
            "name" : "onValue"
            "qualifiedname" : "dart.async._SubscribeFuture._SubscribeFuture#onValue"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "_onError" : 
            "name" : "_onError"
            "qualifiedname" : "dart.async._SubscribeFuture._SubscribeFuture#_onError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureOnError"
            "value" : "null"
      "_zonedSendError" : 
        "name" : "_zonedSendError"
        "qualifiedname" : "dart.async._SubscribeFuture._zonedSendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._SubscribeFuture._zonedSendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
  "_CatchErrorFuture" : 
    "name" : "_CatchErrorFuture"
    "qualifiedname" : "dart.async._CatchErrorFuture"
    "comment" : "<p>Future returned by <code>Future.catchError</code>.</p>"
    "superclass" : "dart.async._TransformFuture"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_test" : 
        "name" : "_test"
        "qualifiedname" : "dart.async._CatchErrorFuture._test"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._FutureErrorTest"
      "_onError" : 
        "name" : "_onError"
        "qualifiedname" : "dart.async._CatchErrorFuture._onError"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._FutureOnError"
    "methods" : 
      "_CatchErrorFuture" : 
        "name" : "_CatchErrorFuture"
        "qualifiedname" : "dart.async._CatchErrorFuture._CatchErrorFuture"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_onError" : 
            "name" : "_onError"
            "qualifiedname" : "dart.async._CatchErrorFuture._CatchErrorFuture#_onError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureOnError"
            "value" : "null"
          "_test" : 
            "name" : "_test"
            "qualifiedname" : "dart.async._CatchErrorFuture._CatchErrorFuture#_test"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureErrorTest"
            "value" : "null"
      "_zonedSendValue" : 
        "name" : "_zonedSendValue"
        "qualifiedname" : "dart.async._CatchErrorFuture._zonedSendValue"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._CatchErrorFuture._zonedSendValue#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._CatchErrorFuture.T"
            "value" : "null"
      "_zonedSendError" : 
        "name" : "_zonedSendError"
        "qualifiedname" : "dart.async._CatchErrorFuture._zonedSendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._CatchErrorFuture._zonedSendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
  "_ThenFuture" : 
    "name" : "_ThenFuture"
    "qualifiedname" : "dart.async._ThenFuture"
    "comment" : "<p>Future returned by <code>Future.then</code> with no <code>:onError:</code> parameter.</p>"
    "superclass" : "dart.async._TransformFuture"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_onValue" : 
        "name" : "_onValue"
        "qualifiedname" : "dart.async._ThenFuture._onValue"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dynamic"
    "methods" : 
      "_ThenFuture" : 
        "name" : "_ThenFuture"
        "qualifiedname" : "dart.async._ThenFuture._ThenFuture"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_onValue" : 
            "name" : "_onValue"
            "qualifiedname" : "dart.async._ThenFuture._ThenFuture#_onValue"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "_zonedSendValue" : 
        "name" : "_zonedSendValue"
        "qualifiedname" : "dart.async._ThenFuture._zonedSendValue"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._ThenFuture._zonedSendValue#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._ThenFuture.S"
            "value" : "null"
      "_zonedSendError" : 
        "name" : "_zonedSendError"
        "qualifiedname" : "dart.async._ThenFuture._zonedSendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._ThenFuture._zonedSendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
  "_FutureAction" : 
    "name" : "_FutureAction"
    "qualifiedname" : "dart.async._FutureAction"
    "comment" : "<p>Used by <code>WhenFuture</code>.</p>"
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_FutureErrorTest" : 
    "name" : "_FutureErrorTest"
    "qualifiedname" : "dart.async._FutureErrorTest"
    "comment" : "<p>Test used by <code>Future.catchError</code> to handle skip some errors.</p>"
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_FutureOnError" : 
    "name" : "_FutureOnError"
    "qualifiedname" : "dart.async._FutureOnError"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_FutureOnValue" : 
    "name" : "_FutureOnValue"
    "qualifiedname" : "dart.async._FutureOnValue"
    "comment" : "<p>The onValue and onError handlers return either a value or a future</p>"
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "_TransformFuture" : 
    "name" : "_TransformFuture"
    "qualifiedname" : "dart.async._TransformFuture"
    "comment" : "<p>Transforming future base class.</p> <p>A transforming future is itself a future and a future listener. Subclasses override <code>_sendValue</code>/<code>_sendError</code> to intercept the results of a previous future.</p>"
    "superclass" : "dart.async._FutureImpl"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
      - "dart.async._FutureListener"
    "variables" : 
      "_nextListener" : 
        "name" : "_nextListener"
        "qualifiedname" : "dart.async._TransformFuture._nextListener"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._FutureListener"
    "methods" : 
      "_TransformFuture" : 
        "name" : "_TransformFuture"
        "qualifiedname" : "dart.async._TransformFuture._TransformFuture"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
      "_sendValue" : 
        "name" : "_sendValue"
        "qualifiedname" : "dart.async._TransformFuture._sendValue"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._TransformFuture._sendValue#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._TransformFuture.S"
            "value" : "null"
      "_sendError" : 
        "name" : "_sendError"
        "qualifiedname" : "dart.async._TransformFuture._sendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._TransformFuture._sendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "_subscribeTo" : 
        "name" : "_subscribeTo"
        "qualifiedname" : "dart.async._TransformFuture._subscribeTo"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "future" : 
            "name" : "future"
            "qualifiedname" : "dart.async._TransformFuture._subscribeTo#future"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureImpl"
            "value" : "null"
      "_zonedSendValue" : 
        "name" : "_zonedSendValue"
        "qualifiedname" : "dart.async._TransformFuture._zonedSendValue"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._TransformFuture._zonedSendValue#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._TransformFuture.S"
            "value" : "null"
      "_zonedSendError" : 
        "name" : "_zonedSendError"
        "qualifiedname" : "dart.async._TransformFuture._zonedSendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._TransformFuture._zonedSendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
  "_FutureImpl" : 
    "name" : "_FutureImpl"
    "qualifiedname" : "dart.async._FutureImpl"
    "comment" : ""
    "superclass" : "dart.core.Object"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
      - "dart.async.Future"
    "variables" : 
      "_INCOMPLETE" : 
        "name" : "_INCOMPLETE"
        "qualifiedname" : "dart.async._FutureImpl._INCOMPLETE"
        "comment" : "<p>Initial state, waiting for a result. In this state, the <code>resultOrListeners</code> field holds a single-linked list of <code>FutureListener</code> listeners.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_CHAINED" : 
        "name" : "_CHAINED"
        "qualifiedname" : "dart.async._FutureImpl._CHAINED"
        "comment" : "<p>The future has been chained to another future. The result of that other future becomes the result of this future as well. In this state, the <code>resultOrListeners</code> field holds the future that will give the result to this future. Both existing and new listeners are forwarded directly to the other future.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_CHAINED_UNLISTENED" : 
        "name" : "_CHAINED_UNLISTENED"
        "qualifiedname" : "dart.async._FutureImpl._CHAINED_UNLISTENED"
        "comment" : "<p>The future has been chained to another future, but there hasn't been any listeners added to this future yet. If it is completed with an error, the error will be considered unhandled.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_VALUE" : 
        "name" : "_VALUE"
        "qualifiedname" : "dart.async._FutureImpl._VALUE"
        "comment" : "<p>The future has been completed with a value result.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_ERROR" : 
        "name" : "_ERROR"
        "qualifiedname" : "dart.async._FutureImpl._ERROR"
        "comment" : "<p>The future has been completed with an error result.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_UNHANDLED_ERROR" : 
        "name" : "_UNHANDLED_ERROR"
        "qualifiedname" : "dart.async._FutureImpl._UNHANDLED_ERROR"
        "comment" : "<p>Extra bit set when the future has been completed with an error result. but no listener has been scheduled to receive the error. If the bit is still set when a <code>runAsync</code> call triggers, the error will be reported to the top-level handler. Assigning a listener before that time will clear the bit.</p>"
        "final" : "false"
        "static" : "true"
        "type" : "dart.core.int"
      "_state" : 
        "name" : "_state"
        "qualifiedname" : "dart.async._FutureImpl._state"
        "comment" : "<p>Whether the future is complete, and as what.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.int"
      "_zone" : 
        "name" : "_zone"
        "qualifiedname" : "dart.async._FutureImpl._zone"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._Zone"
      "_resultOrListeners" : 
        "name" : "_resultOrListeners"
        "qualifiedname" : "dart.async._FutureImpl._resultOrListeners"
        "comment" : "<p>Either the result, a list of listeners or another future.</p> <p>The result of the future is either a value or an error. A result is only stored when the future has completed.</p> <p>The listeners is an internally linked list of <code>_FutureListener</code>s. Listeners are only remembered while the future is not yet complete, and it is not chained to another future.</p> <p>The future is another future that his future is chained to. This future is waiting for the other future to complete, and when it does, this future will complete with the same result. All listeners are forwarded to the other future.</p> <p>The cases are disjoint (incomplete and unchained, incomplete and chained, or completed with value or error), so the field only needs to hold one value at a time.</p>"
        "final" : "false"
        "static" : "false"
        "type" : "dynamic"
    "methods" : 
      "_isChained" : 
        "name" : "_isChained"
        "qualifiedname" : "dart.async._FutureImpl._isChained"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_hasChainedListener" : 
        "name" : "_hasChainedListener"
        "qualifiedname" : "dart.async._FutureImpl._hasChainedListener"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_isComplete" : 
        "name" : "_isComplete"
        "qualifiedname" : "dart.async._FutureImpl._isComplete"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_hasValue" : 
        "name" : "_hasValue"
        "qualifiedname" : "dart.async._FutureImpl._hasValue"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_hasError" : 
        "name" : "_hasError"
        "qualifiedname" : "dart.async._FutureImpl._hasError"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_hasUnhandledError" : 
        "name" : "_hasUnhandledError"
        "qualifiedname" : "dart.async._FutureImpl._hasUnhandledError"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
      "_clearUnhandledError" : 
        "name" : "_clearUnhandledError"
        "qualifiedname" : "dart.async._FutureImpl._clearUnhandledError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_FutureImpl" : 
        "name" : "_FutureImpl"
        "qualifiedname" : "dart.async._FutureImpl._FutureImpl"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
      "_FutureImpl.immediate" : 
        "name" : "_FutureImpl.immediate"
        "qualifiedname" : "dart.async._FutureImpl._FutureImpl.immediate"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._FutureImpl._FutureImpl.immediate#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureImpl.T"
            "value" : "null"
      "_FutureImpl.immediateError" : 
        "name" : "_FutureImpl.immediateError"
        "qualifiedname" : "dart.async._FutureImpl._FutureImpl.immediateError"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._FutureImpl._FutureImpl.immediateError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
          "stackTrace" : 
            "name" : "stackTrace"
            "qualifiedname" : "dart.async._FutureImpl._FutureImpl.immediateError#stackTrace"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "_FutureImpl.wait" : 
        "name" : "_FutureImpl.wait"
        "qualifiedname" : "dart.async._FutureImpl._FutureImpl.wait"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async._FutureImpl"
        "parameters" : 
          "futures" : 
            "name" : "futures"
            "qualifiedname" : "dart.async._FutureImpl._FutureImpl.wait#futures"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Iterable"
            "value" : "null"
      "then" : 
        "name" : "then"
        "qualifiedname" : "dart.async._FutureImpl.then"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._FutureImpl.then#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async._FutureImpl.then#onError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "catchError" : 
        "name" : "catchError"
        "qualifiedname" : "dart.async._FutureImpl.catchError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async._FutureImpl.catchError#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async._FutureImpl.catchError#test"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "whenComplete" : 
        "name" : "whenComplete"
        "qualifiedname" : "dart.async._FutureImpl.whenComplete"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "action" : 
            "name" : "action"
            "qualifiedname" : "dart.async._FutureImpl.whenComplete#action"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "asStream" : 
        "name" : "asStream"
        "qualifiedname" : "dart.async._FutureImpl.asStream"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
      "_inSameErrorZone" : 
        "name" : "_inSameErrorZone"
        "qualifiedname" : "dart.async._FutureImpl._inSameErrorZone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
          "otherZone" : 
            "name" : "otherZone"
            "qualifiedname" : "dart.async._FutureImpl._inSameErrorZone#otherZone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
      "_setValue" : 
        "name" : "_setValue"
        "qualifiedname" : "dart.async._FutureImpl._setValue"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._FutureImpl._setValue#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureImpl.T"
            "value" : "null"
      "_setError" : 
        "name" : "_setError"
        "qualifiedname" : "dart.async._FutureImpl._setError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._FutureImpl._setError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "_scheduleUnhandledError" : 
        "name" : "_scheduleUnhandledError"
        "qualifiedname" : "dart.async._FutureImpl._scheduleUnhandledError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
      "_addListener" : 
        "name" : "_addListener"
        "qualifiedname" : "dart.async._FutureImpl._addListener"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "listener" : 
            "name" : "listener"
            "qualifiedname" : "dart.async._FutureImpl._addListener#listener"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureListener"
            "value" : "null"
      "_removeListeners" : 
        "name" : "_removeListeners"
        "qualifiedname" : "dart.async._FutureImpl._removeListeners"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async._FutureListener"
        "parameters" : 
      "_chain" : 
        "name" : "_chain"
        "qualifiedname" : "dart.async._FutureImpl._chain"
        "comment" : "<p>Make another <code>_FutureImpl</code> receive the result of this one.</p> <p>If this future is already complete, the <code>future</code> is notified immediately. This function is only called during event resolution where it's acceptable to send an event.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "future" : 
            "name" : "future"
            "qualifiedname" : "dart.async._FutureImpl._chain#future"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureImpl"
            "value" : "null"
      "_chainSource" : 
        "name" : "_chainSource"
        "qualifiedname" : "dart.async._FutureImpl._chainSource"
        "comment" : "<p>Returns the future that this future is chained to.</p> <p>If that future is itself chained to something else, get the <code>_chainSource</code> of that future instead, and make this future chain directly to the earliest source.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async._FutureImpl"
        "parameters" : 
      "_chainFromFuture" : 
        "name" : "_chainFromFuture"
        "qualifiedname" : "dart.async._FutureImpl._chainFromFuture"
        "comment" : "<p>Make this incomplete future end up with the same result as <code>resultSource</code>.</p> <p>This is done by moving all listeners to <code>resultSource</code> and forwarding all future <code>_addListener</code> calls to <code>resultSource</code> directly.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "resultSource" : 
            "name" : "resultSource"
            "qualifiedname" : "dart.async._FutureImpl._chainFromFuture#resultSource"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureImpl"
            "value" : "null"
      "_setOrChainValue" : 
        "name" : "_setOrChainValue"
        "qualifiedname" : "dart.async._FutureImpl._setOrChainValue"
        "comment" : "<p>Helper function to handle the result of transforming an incoming event.</p> <p>If the result is itself a <code>Future</code>, this future is linked to that future's output. If not, this future is completed with the result.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "result" : 
            "name" : "result"
            "qualifiedname" : "dart.async._FutureImpl._setOrChainValue#result"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "_asListener" : 
        "name" : "_asListener"
        "qualifiedname" : "dart.async._FutureImpl._asListener"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.async._FutureListener"
        "parameters" : 
  "_ErrorZoneBoundaryListener" : 
    "name" : "_ErrorZoneBoundaryListener"
    "qualifiedname" : "dart.async._ErrorZoneBoundaryListener"
    "comment" : "<p>This listener is installed at error-zone boundaries. It signals an uncaught error in the zone of origin when an error is sent from one error zone to another.</p> <p>When a Future is listening to another Future and they have not been instantiated in the same error-zone then Futures put an instance of this class between them (see [_FutureImpl._addListener]).</p> <p>For example:</p> <pre><code>var completer = new Completer(); var future = completer.future.then((x) =&gt; x); catchErrors(() {   var future2 = future.catchError(print); }); completer.completeError(499); </code></pre> <p>In this example <code>future</code> and <code>future2</code> are in different error-zones. The error (499) that originates outside <code>catchErrors</code> must not reach the <code>catchError</code> future (<code>future2</code>) inside <code>catchErrors</code>.</p> <p>When invoking <code>catchError</code> on <code>future</code> the Future installs an <code>_ErrorZoneBoundaryListener</code> between itself and the result, <code>future2</code>.</p> <p>Conceptually _ErrorZoneBoundaryListeners could be implemented as <code>catchError</code>s on the origin future as well.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
      - "dart.async._FutureListener"
    "variables" : 
      "_nextListener" : 
        "name" : "_nextListener"
        "qualifiedname" : "dart.async._ErrorZoneBoundaryListener._nextListener"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._FutureListener"
      "_listener" : 
        "name" : "_listener"
        "qualifiedname" : "dart.async._ErrorZoneBoundaryListener._listener"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async._FutureListener"
    "methods" : 
      "_ErrorZoneBoundaryListener" : 
        "name" : "_ErrorZoneBoundaryListener"
        "qualifiedname" : "dart.async._ErrorZoneBoundaryListener._ErrorZoneBoundaryListener"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "_listener" : 
            "name" : "_listener"
            "qualifiedname" : "dart.async._ErrorZoneBoundaryListener._ErrorZoneBoundaryListener#_listener"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureListener"
            "value" : "null"
      "_inSameErrorZone" : 
        "name" : "_inSameErrorZone"
        "qualifiedname" : "dart.async._ErrorZoneBoundaryListener._inSameErrorZone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
          "otherZone" : 
            "name" : "otherZone"
            "qualifiedname" : "dart.async._ErrorZoneBoundaryListener._inSameErrorZone#otherZone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
      "_sendValue" : 
        "name" : "_sendValue"
        "qualifiedname" : "dart.async._ErrorZoneBoundaryListener._sendValue"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._ErrorZoneBoundaryListener._sendValue#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "_sendError" : 
        "name" : "_sendError"
        "qualifiedname" : "dart.async._ErrorZoneBoundaryListener._sendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._ErrorZoneBoundaryListener._sendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
  "_FutureListenerWrapper" : 
    "name" : "_FutureListenerWrapper"
    "qualifiedname" : "dart.async._FutureListenerWrapper"
    "comment" : "<p>Adapter for a <code>_FutureImpl</code> to be a future result listener.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
      - "dart.async._FutureListener"
    "variables" : 
      "future" : 
        "name" : "future"
        "qualifiedname" : "dart.async._FutureListenerWrapper.future"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._FutureImpl"
      "_nextListener" : 
        "name" : "_nextListener"
        "qualifiedname" : "dart.async._FutureListenerWrapper._nextListener"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._FutureListener"
    "methods" : 
      "_FutureListenerWrapper" : 
        "name" : "_FutureListenerWrapper"
        "qualifiedname" : "dart.async._FutureListenerWrapper._FutureListenerWrapper"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "future" : 
            "name" : "future"
            "qualifiedname" : "dart.async._FutureListenerWrapper._FutureListenerWrapper#future"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureImpl"
            "value" : "null"
      "_sendValue" : 
        "name" : "_sendValue"
        "qualifiedname" : "dart.async._FutureListenerWrapper._sendValue"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._FutureListenerWrapper._sendValue#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureListenerWrapper.T"
            "value" : "null"
      "_sendError" : 
        "name" : "_sendError"
        "qualifiedname" : "dart.async._FutureListenerWrapper._sendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._FutureListenerWrapper._sendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "_inSameErrorZone" : 
        "name" : "_inSameErrorZone"
        "qualifiedname" : "dart.async._FutureListenerWrapper._inSameErrorZone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
          "otherZone" : 
            "name" : "otherZone"
            "qualifiedname" : "dart.async._FutureListenerWrapper._inSameErrorZone#otherZone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
  "_FutureListener" : 
    "name" : "_FutureListener"
    "qualifiedname" : "dart.async._FutureListener"
    "comment" : "<p>A listener on a future.</p> <p>When the future completes, the <code>_sendValue</code> or <code>_sendError</code> method is invoked with the result.</p> <p>Listeners are kept in a linked list.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "_nextListener" : 
        "name" : "_nextListener"
        "qualifiedname" : "dart.async._FutureListener._nextListener"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.async._FutureListener"
    "methods" : 
      "_FutureListener.wrap" : 
        "name" : "_FutureListener.wrap"
        "qualifiedname" : "dart.async._FutureListener._FutureListener.wrap"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async._FutureListener"
        "parameters" : 
          "future" : 
            "name" : "future"
            "qualifiedname" : "dart.async._FutureListener._FutureListener.wrap#future"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureImpl"
            "value" : "null"
      "_sendValue" : 
        "name" : "_sendValue"
        "qualifiedname" : "dart.async._FutureListener._sendValue"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._FutureListener._sendValue#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._FutureListener.T"
            "value" : "null"
      "_sendError" : 
        "name" : "_sendError"
        "qualifiedname" : "dart.async._FutureListener._sendError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._FutureListener._sendError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "_inSameErrorZone" : 
        "name" : "_inSameErrorZone"
        "qualifiedname" : "dart.async._FutureListener._inSameErrorZone"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
          "otherZone" : 
            "name" : "otherZone"
            "qualifiedname" : "dart.async._FutureListener._inSameErrorZone#otherZone"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Zone"
            "value" : "null"
  "_SyncCompleter" : 
    "name" : "_SyncCompleter"
    "qualifiedname" : "dart.async._SyncCompleter"
    "comment" : ""
    "superclass" : "dart.async._Completer"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "_setFutureValue" : 
        "name" : "_setFutureValue"
        "qualifiedname" : "dart.async._SyncCompleter._setFutureValue"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._SyncCompleter._setFutureValue#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._SyncCompleter.T"
            "value" : "null"
      "_setFutureError" : 
        "name" : "_setFutureError"
        "qualifiedname" : "dart.async._SyncCompleter._setFutureError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._SyncCompleter._setFutureError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
  "_AsyncCompleter" : 
    "name" : "_AsyncCompleter"
    "qualifiedname" : "dart.async._AsyncCompleter"
    "comment" : ""
    "superclass" : "dart.async._Completer"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "_setFutureValue" : 
        "name" : "_setFutureValue"
        "qualifiedname" : "dart.async._AsyncCompleter._setFutureValue"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._AsyncCompleter._setFutureValue#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._AsyncCompleter.T"
            "value" : "null"
      "_setFutureError" : 
        "name" : "_setFutureError"
        "qualifiedname" : "dart.async._AsyncCompleter._setFutureError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._AsyncCompleter._setFutureError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
  "_Completer" : 
    "name" : "_Completer"
    "qualifiedname" : "dart.async._Completer"
    "comment" : ""
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
      - "dart.async.Completer"
    "variables" : 
      "future" : 
        "name" : "future"
        "qualifiedname" : "dart.async._Completer.future"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.async.Future"
      "_isComplete" : 
        "name" : "_isComplete"
        "qualifiedname" : "dart.async._Completer._isComplete"
        "comment" : ""
        "final" : "false"
        "static" : "false"
        "type" : "dart.core.bool"
    "methods" : 
      "_Completer" : 
        "name" : "_Completer"
        "qualifiedname" : "dart.async._Completer._Completer"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
      "_setFutureValue" : 
        "name" : "_setFutureValue"
        "qualifiedname" : "dart.async._Completer._setFutureValue"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._Completer._setFutureValue#value"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Completer.T"
            "value" : "null"
      "_setFutureError" : 
        "name" : "_setFutureError"
        "qualifiedname" : "dart.async._Completer._setFutureError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._Completer._setFutureError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
      "complete" : 
        "name" : "complete"
        "qualifiedname" : "dart.async._Completer.complete"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async._Completer.complete#value"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async._Completer.T"
            "value" : "null"
      "completeError" : 
        "name" : "completeError"
        "qualifiedname" : "dart.async._Completer.completeError"
        "comment" : ""
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async._Completer.completeError#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
          "stackTrace" : 
            "name" : "stackTrace"
            "qualifiedname" : "dart.async._Completer.completeError#stackTrace"
            "optional" : "true"
            "named" : "false"
            "default" : "true"
            "type" : "dart.core.Object"
            "value" : "null"
      "isCompleted" : 
        "name" : "isCompleted"
        "qualifiedname" : "dart.async._Completer.isCompleted"
        "comment" : ""
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
  "Completer" : 
    "name" : "Completer"
    "qualifiedname" : "dart.async.Completer"
    "comment" : "<p>A <code>Completer</code> is used to produce <code>Future</code>s and supply their value when it becomes available.</p> <p>A service that provides values to callers, and wants to return <code>Future</code>s can use a <code>Completer</code> as follows:</p> <pre><code>Completer completer = new Completer(); // send future object back to client... return completer.future; ...  // later when value is available, call: completer.complete(value);  // alternatively, if the service cannot produce the value, it // can provide an error: completer.completeError(error); </code></pre>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "Completer" : 
        "name" : "Completer"
        "qualifiedname" : "dart.async.Completer.Completer"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.Completer"
        "parameters" : 
      "Completer.sync" : 
        "name" : "Completer.sync"
        "qualifiedname" : "dart.async.Completer.Completer.sync"
        "comment" : "<p>Completes the future synchronously.</p> <p>This constructor should be avoided unless the completion of the future is known to be the final result of another asynchronous operation. If in doubt use the default <code>Completer</code> constructor.</p> <p>Example:</p> <pre><code>var completer = new Completer.sync(); // The completion is the result of the asynchronous onDone event. // No other operation is performed after the completion. It is safe // to use the Completer.sync constructor. stream.listen(print, onDone: () { completer.complete(\"done\"); }); </code></pre> <p>Bad example. Do not use this code. Only for illustrative purposes:</p> <pre><code>var completer = new Completer.sync(); // The completion is the result of the asynchronous onDone event. // However, there is still code executed after the completion. This // operation is *not* safe. stream.listen(print, onDone: () {   completer.complete(\"done\");   foo();  // This operation follows the completion. }); </code></pre> <p><em>WARNING</em> This constructor is experimental and could disappear or change behavior.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.Completer"
        "parameters" : 
      "future" : 
        "name" : "future"
        "qualifiedname" : "dart.async.Completer.future"
        "comment" : "<p>The future that will contain the result provided to this completer.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
      "complete" : 
        "name" : "complete"
        "qualifiedname" : "dart.async.Completer.complete"
        "comment" : "<p>Completes <code>future</code> with the supplied values.</p> <p>All listeners on the future will be immediately informed about the value.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async.Completer.complete#value"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Completer.T"
            "value" : "null"
      "completeError" : 
        "name" : "completeError"
        "qualifiedname" : "dart.async.Completer.completeError"
        "comment" : "<p>Complete <code>future</code> with an error.</p> <p>Completing a future with an error indicates that an exception was thrown while trying to produce a value.</p> <p>The argument <code>exception</code> should not be <code>null</code>.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "void"
        "parameters" : 
          "exception" : 
            "name" : "exception"
            "qualifiedname" : "dart.async.Completer.completeError#exception"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
          "stackTrace" : 
            "name" : "stackTrace"
            "qualifiedname" : "dart.async.Completer.completeError#stackTrace"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "isCompleted" : 
        "name" : "isCompleted"
        "qualifiedname" : "dart.async.Completer.isCompleted"
        "comment" : "<p>Whether the future has been completed.</p>"
        "type" : "getter"
        "static" : "false"
        "return" : "dart.core.bool"
        "parameters" : 
  "Future" : 
    "name" : "Future"
    "qualifiedname" : "dart.async.Future"
    "comment" : "<p>A <code>Future</code> represents a delayed computation. It is used to obtain a not-yet available value, or error, sometime in the future.  Receivers of a <code>Future</code> can register callbacks that handle the value or error once it is available. For example:</p> <pre><code>Future&lt;int&gt; future = getFuture(); future.then((value) =&gt; handleValue(value))       .catchError((error) =&gt; handleError(error)); </code></pre> <p>A <code>Future</code> can be completed in two ways: with a value (\"the future succeeds\") or with an error (\"the future fails\"). Users can install callbacks for each case. The result of registering a pair of callbacks is a new Future (the \"successor\") which in turn is completed with the result of invoking the corresponding callback. The successor is completed with an error if the invoked callback throws. For example:</p> <pre><code>Future&lt;int&gt; successor = future.then((int value) {     // Invoked when the future is completed with a value.     return 42;  // The successor is completed with the value 42.   },   onError: (e) {     // Invoked when the future is completed with an error.     if (canHandle(e)) {       return 499;  // The successor is completed with the value 499.     } else {       throw e;  // The successor is completed with the error e.     }   }); </code></pre> <p>If a future does not have a successor but is completed with an error, it forwards the error message to the global error-handler. This special casing makes sure that no error is silently dropped. However, it also means that error handlers should be installed early, so that they are present as soon as a future is completed with an error. The following example demonstrates this potential bug:</p> <pre><code>var future = getFuture(); new Timer(new Duration(milliseconds: 5), () {   // The error-handler is only attached 5ms after the future has been   // received. If the future fails in the mean-time it will forward the   // error to the global error-handler, even though there is code (just   // below) to handle the error.   future.then((value) { useValue(value); },               onError: (e) { handleError(e); }); }); </code></pre> <p>In general we discourage registering the two callbacks at the same time, but prefer to use <code>then</code> with one argument (the value handler), and to use <code>catchError</code> for handling errors. The missing callbacks (the error-handler for <code>then</code>, and the value-handler for <code>catchError</code>), are automatically configured to \"forward\" the value/error. Separating value and error-handling into separate registration calls usually leads to code that is easier to reason about. In fact it makes asynchronous code very similar to synchronous code:</p> <pre><code>// Synchronous code. try {   int value = foo();   return bar(value); } catch (e) {   return 499; } </code></pre> <p> Equivalent asynchronous code, based on futures:</p> <pre><code>Future&lt;int&gt; future = foo();  // foo now returns a future. future.then((int value) =&gt; bar(value))       .catchError((e) =&gt; 499); </code></pre> <p>Similar to the synchronous code, the error handler (registered with <code>catchError</code>) is handling the errors for exceptions coming from calls to 'foo', as well as 'bar'. This would not be the case if the error-handler was registered at the same time as the value-handler.</p> <p>Futures can have more than one callback-pairs registered. Each successor is treated independently and is handled as if it was the only successor.</p>"
    "superclass" : "dart.core.Object"
    "abstract" : "true"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "Future" : 
        "name" : "Future"
        "qualifiedname" : "dart.async.Future.Future"
        "comment" : "<p>Creates a future containing the result of calling <code>computation</code> asynchronously with <code>runAsync</code>.</p> <p>if the result of executing <code>computation</code> throws, the returned future is completed with the error. If a thrown value is an <code>AsyncError</code>, it is used directly, instead of wrapping this error again in another <code>AsyncError</code>.</p> <p>If the returned value is itself a <code>Future</code>, completion of the created future will wait until the returned future completes, and will then complete with the same result.</p> <p>If a value is returned, it becomes the result of the created future.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "computation" : 
            "name" : "computation"
            "qualifiedname" : "dart.async.Future.Future#computation"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "Future.sync" : 
        "name" : "Future.sync"
        "qualifiedname" : "dart.async.Future.Future.sync"
        "comment" : "<p>Creates a future containing the result of immediately calling <code>computation</code>.</p> <p>if the result of executing <code>computation</code> throws, the returned future is completed with the error. If a thrown value is an <code>AsyncError</code>, it is used directly, instead of wrapping this error again in another <code>AsyncError</code>.</p> <p>If the returned value is itself a <code>Future</code>, completion of the created future will wait until the returned future completes, and will then complete with the same result.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "computation" : 
            "name" : "computation"
            "qualifiedname" : "dart.async.Future.Future.sync#computation"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "Future.value" : 
        "name" : "Future.value"
        "qualifiedname" : "dart.async.Future.Future.value"
        "comment" : "<p>A future whose value is available in the next event-loop iteration.</p> <p>If <code>value</code> is not a <code>Future</code>, using this constructor is equivalent to <code>:new Future.sync(() => value):</code>.</p> <p>See <code>Completer</code> to create a Future and complete it later.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "value" : 
            "name" : "value"
            "qualifiedname" : "dart.async.Future.Future.value#value"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.async.Future.T"
            "value" : "null"
      "Future.error" : 
        "name" : "Future.error"
        "qualifiedname" : "dart.async.Future.Future.error"
        "comment" : "<p>A future that completes with an error in the next event-loop iteration.</p> <p>See <code>Completer</code> to create a Future and complete it later.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "error" : 
            "name" : "error"
            "qualifiedname" : "dart.async.Future.Future.error#error"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dynamic"
            "value" : "null"
          "stackTrace" : 
            "name" : "stackTrace"
            "qualifiedname" : "dart.async.Future.Future.error#stackTrace"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Object"
            "value" : "null"
      "Future.delayed" : 
        "name" : "Future.delayed"
        "qualifiedname" : "dart.async.Future.Future.delayed"
        "comment" : "<p>Creates a future that completes after a delay.</p> <p>The future will be completed after the given <code>duration</code> has passed with the result of calling <code>computation</code>. If the duration is 0 or less, it completes no sooner than in the next event-loop iteration.</p> <p>If <code>computation</code> is not given or <code>:null:</code> then it will behave as if <code>computation</code> was set to <code>:() => null:</code>. That is, it will complete with <code>:null:</code>.</p> <p>If calling <code>computation</code> throws, the created future will complete with the error.</p> <p>See <code>Completer</code>s, for futures with values that are computed asynchronously.</p>"
        "type" : "constructor"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "duration" : 
            "name" : "duration"
            "qualifiedname" : "dart.async.Future.Future.delayed#duration"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Duration"
            "value" : "null"
          "computation" : 
            "name" : "computation"
            "qualifiedname" : "dart.async.Future.Future.delayed#computation"
            "optional" : "true"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "wait" : 
        "name" : "wait"
        "qualifiedname" : "dart.async.Future.wait"
        "comment" : "<p>Wait for all the given futures to complete and collect their values.</p> <p>Returns a future which will complete once all the futures in a list are complete. If any of the futures in the list completes with an error, the resulting future also completes with an error. Otherwise the value of the returned future will be a list of all the values that were produced.</p>"
        "type" : "method"
        "static" : "true"
        "return" : "dart.async.Future"
        "parameters" : 
          "futures" : 
            "name" : "futures"
            "qualifiedname" : "dart.async.Future.wait#futures"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Iterable"
            "value" : "null"
      "forEach" : 
        "name" : "forEach"
        "qualifiedname" : "dart.async.Future.forEach"
        "comment" : "<p>Perform an async operation for each element of the iterable, in turn.</p> <p>Runs <code>f</code> for each element in <code>input</code> in order, moving to the next element only when the <code>Future</code> returned by <code>f</code> completes. Returns a <code>Future</code> that completes when all elements have been processed.</p> <p>The return values of all <code>Future</code>s are discarded. Any errors will cause the iteration to stop and will be piped through the returned <code>Future</code>.</p>"
        "type" : "method"
        "static" : "true"
        "return" : "dart.async.Future"
        "parameters" : 
          "input" : 
            "name" : "input"
            "qualifiedname" : "dart.async.Future.forEach#input"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Iterable"
            "value" : "null"
          "f" : 
            "name" : "f"
            "qualifiedname" : "dart.async.Future.forEach#f"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "then" : 
        "name" : "then"
        "qualifiedname" : "dart.async.Future.then"
        "comment" : "<p>When this future completes with a value, then <code>onValue</code> is called with this value. If <code>this</code> future is already completed then the invocation of <code>onValue</code> is delayed until the next event-loop iteration.</p> <p>Returns a new <code>Future</code> <code>f</code> which is completed with the result of invoking <code>onValue</code> (if <code>this</code> completes with a value) or <code>onError</code> (if <code>this</code> completes with an error).</p> <p>If the invoked callback throws an exception, the returned future <code>f</code> is completed with the error.</p> <p>If the invoked callback returns a <code>Future</code> <code>f2</code> then <code>f</code> and <code>f2</code> are chained. That is, <code>f</code> is completed with the completion value of <code>f2</code>.</p> <p>If <code>onError</code> is not given, it is equivalent to <code>(e) { throw e; }</code>. That is, it forwards the error to <code>f</code>.</p> <p>In most cases, it is more readable to use <code>catchError</code> separately, possibly with a <code>test</code> parameter, instead of handling both value and error in a single <code>then</code> call.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "onValue" : 
            "name" : "onValue"
            "qualifiedname" : "dart.async.Future.then#onValue"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async.Future.then#onError"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "catchError" : 
        "name" : "catchError"
        "qualifiedname" : "dart.async.Future.catchError"
        "comment" : "<p>Handles errors emitted by this <code>Future</code>.</p> <p>Returns a new <code>Future</code> <code>f</code>.</p> <p>When <code>this</code> completes with a value, the value is forwarded to <code>f</code> unmodified. That is, <code>f</code> completes with the same value.</p> <p>When <code>this</code> completes with an error, <code>test</code> is called with the error's value. If the invocation returns <code>true</code>, <code>onError</code> is called with the error. The result of <code>onError</code> is handled exactly the same as for <code>then</code>'s <code>onError</code>.</p> <p>If <code>test</code> returns false, the exception is not handled by <code>onError</code>, but is thrown unmodified, thus forwarding it to <code>f</code>.</p> <p>If <code>test</code> is omitted, it defaults to a function that always returns true.</p> <p>Example:</p> <pre><code>foo   .catchError(..., test: (e) =&gt; e is ArgumentError)   .catchError(..., test: (e) =&gt; e is NoSuchMethodError)   .then((v) { ... }); </code></pre> <p>This method is equivalent to:</p> <pre><code>Future catchError(onError(error),                   {bool test(error)}) {   this.then((v) =&gt; v,  // Forward the value.             // But handle errors, if the [test] succeeds.             onError: (e) {               if (test == null || test(e)) {                 return onError(e);               }               throw e;             }); } </code></pre>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "onError" : 
            "name" : "onError"
            "qualifiedname" : "dart.async.Future.catchError#onError"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
          "test" : 
            "name" : "test"
            "qualifiedname" : "dart.async.Future.catchError#test"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "whenComplete" : 
        "name" : "whenComplete"
        "qualifiedname" : "dart.async.Future.whenComplete"
        "comment" : "<p>Register a function to be called when this future completes.</p> <p>The <code>action</code> function is called when this future completes, whether it does so with a value or with an error.</p> <p>This is the asynchronous equivalent of a \"finally\" block.</p> <p>The future returned by this call, <code>f</code>, will complete the same way as this future unless an error occurs in the <code>action</code> call, or in a <code>Future</code> returned by the <code>action</code> call. If the call to <code>action</code> does not return a future, its return value is ignored.</p> <p>If the call to <code>action</code> throws, then <code>f</code> is completed with the thrown error.</p> <p>If the call to <code>action</code> returns a <code>Future</code>, <code>f2</code>, then completion of <code>f</code> is delayed until <code>f2</code> completes. If <code>f2</code> completes with an error, that will be the result of <code>f</code> too. The value of <code>f2</code> is always ignored.</p> <p>This method is equivalent to:</p> <pre><code>Future&lt;T&gt; whenComplete(action()) {   this.then((v) {               var f2 = action();               if (f2 is Future) return f2.then((_) =&gt; v);               return v             },             onError: (e) {               var f2 = action();               if (f2 is Future) return f2.then((_) { throw e; });               throw e;             }); } </code></pre>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
          "action" : 
            "name" : "action"
            "qualifiedname" : "dart.async.Future.whenComplete#action"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
      "asStream" : 
        "name" : "asStream"
        "qualifiedname" : "dart.async.Future.asStream"
        "comment" : "<p>Creates a <code>Stream</code> that sends <code>this</code>' completion value, data or error, to its subscribers. The stream closes after the completion value.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Stream"
        "parameters" : 
  "_AsyncRun" : 
    "name" : "_AsyncRun"
    "qualifiedname" : "dart.async._AsyncRun"
    "comment" : ""
    "superclass" : "dart.core.Object"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
    "methods" : 
      "_enqueueImmediate" : 
        "name" : "_enqueueImmediate"
        "qualifiedname" : "dart.async._AsyncRun._enqueueImmediate"
        "comment" : "<p>Enqueues the given callback before any other event in the event-loop.</p>"
        "type" : "method"
        "static" : "true"
        "return" : "void"
        "parameters" : 
          "callback" : 
            "name" : "callback"
            "qualifiedname" : "dart.async._AsyncRun._enqueueImmediate#callback"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.Function"
            "value" : "null"
  "_AsyncCallback" : 
    "name" : "_AsyncCallback"
    "qualifiedname" : "dart.async._AsyncCallback"
    "comment" : ""
    "superclass" : ""
    "abstract" : "false"
    "typedef" : "true"
    "implements" : 
    "variables" : 
    "methods" : 
  "DeferredLibrary" : 
    "name" : "DeferredLibrary"
    "qualifiedname" : "dart.async.DeferredLibrary"
    "comment" : "<p>Indicates that loading of <code>libraryName</code> is deferred.</p> <p>Applies to library imports, when used as metadata.</p> <p>Example usage:</p> <pre><code>@lazy import 'foo.dart' as foo;  const lazy = const DeferredLibrary('com.example.foo');  void main() {   foo.method(); // Throws a NoSuchMethodError, foo is not loaded yet.   lazy.load().then(onFooLoaded); }  void onFooLoaded(_) {   foo.method(); } </code></pre>"
    "superclass" : "dart.core.Object"
    "abstract" : "false"
    "typedef" : "false"
    "implements" : 
    "variables" : 
      "libraryName" : 
        "name" : "libraryName"
        "qualifiedname" : "dart.async.DeferredLibrary.libraryName"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.core.String"
      "uri" : 
        "name" : "uri"
        "qualifiedname" : "dart.async.DeferredLibrary.uri"
        "comment" : ""
        "final" : "true"
        "static" : "false"
        "type" : "dart.core.String"
    "methods" : 
      "DeferredLibrary" : 
        "name" : "DeferredLibrary"
        "qualifiedname" : "dart.async.DeferredLibrary.DeferredLibrary"
        "comment" : ""
        "type" : "constructor"
        "static" : "false"
        "return" : "dynamic"
        "parameters" : 
          "libraryName" : 
            "name" : "libraryName"
            "qualifiedname" : "dart.async.DeferredLibrary.DeferredLibrary#libraryName"
            "optional" : "false"
            "named" : "false"
            "default" : "false"
            "type" : "dart.core.String"
            "value" : "null"
          "uri" : 
            "name" : "uri"
            "qualifiedname" : "dart.async.DeferredLibrary.DeferredLibrary#uri"
            "optional" : "true"
            "named" : "true"
            "default" : "false"
            "type" : "dart.core.String"
            "value" : "null"
      "load" : 
        "name" : "load"
        "qualifiedname" : "dart.async.DeferredLibrary.load"
        "comment" : "<p>Ensure that <code>libraryName</code> has been loaded.</p> <p>The value of the returned future is true if this invocation of <code>load</code> caused the library to be loaded.</p>"
        "type" : "method"
        "static" : "false"
        "return" : "dart.async.Future"
        "parameters" : 
