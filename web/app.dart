/**
 * This application displays documentation generated by the docgen tool
 * found at dart-repo/dart/pkg/docgen. 
 * 
 * The Yaml file outputted by the docgen tool will be read in to 
 * generate [Page] and [Category] and [CategoryItem]. 
 * Pages, Categories and CategoryItems are used to format and layout the page. 
 */
// TODO(janicejl): Add a link to the dart docgen landing page in future. 
library dartdoc_viewer;

import 'dart:html';
import 'package:web_ui/web_ui.dart';
import 'package:dartdoc_viewer/data.dart';
import 'package:dartdoc_viewer/item.dart';
import 'package:dartdoc_viewer/read_yaml.dart';

// TODO(janicejl): YAML path should not be hardcoded. 
// Path to the YAML file being read in. 
const sourcePath = "../../test/yaml/large_test.yaml";

// Function to set the title of the current page. 
String get title => currentPage == null ? "" : currentPage.simpleName;

// The correct comment for the current page.
String get comment => currentPage != null ? currentPage.comment : "";

// The homepage from which every [Item] can be reached.
@observable Item homePage;

// The current page being shown.
@observable Item currentPage;

/**
 * Changes the currentPage to the page of the item clicked
 * without pushing state onto the history.
 */
changePageWithoutState(Item page) {
  if (page != null) {
    currentPage = page;
    loadValues();
  }
}

/**
 * Pushes state onto the history before updating the [currentPage].
 */
changePage(Item page) {
  if (page != null && currentPage != page) {
    var state = page.path;
    var title = state.substring(0, state.length - 1);
    window.history.pushState(state, title, "/#$state");
  }
  changePageWithoutState(page);
}

/**
 * Creates a list of [Item] objects from the [path] describing the
 * path to a particular [Item] object.
 */
List<Item> getBreadcrumbs(String path) {
  var breadcrumbs = [];
  // Matches alphanumeric variable/method names ending with a '/'.  
  var regex = new RegExp(r"(_?([a-zA-Z0-9]+)=?)/");
  var matches = regex.allMatches(path);
  var currentPath = "";
  matches.forEach((match) {
    currentPath = "$currentPath${match.group(0)}";
    breadcrumbs.add(pageIndex[currentPath]);
  });
  return breadcrumbs;
}

/**
 * Runs through the member structure and creates path information and
 * populates the [pageIndex] map for proper linking.
 */
void buildHierarchy(CategoryItem page, Item previous) {
  if (page is Item) {
    page.path = previous.path == null ?
        "${page.simpleName}/" : "${previous.path}${page.simpleName}/";
    pageIndex[page.path] = page;
    page.content.forEach((subChild) {
      buildHierarchy(subChild, page);
    });
  } else if (page is Category) {
    page.content.forEach((subChild) {
      buildHierarchy(subChild, previous);
    });
  }
}

/**
 * Generates an HTML [Element] for the return type of a method or 
 * the type of a variable.
 */
// This cannot go in lib/item.dart since web/app.dart cannot be imported.
Element getPrefix() {
  var location = currentPage.location;
  if (location == null) {
    return new Element.html("<p>${currentPage.simpleType}</p>");
  } else {
    var link = new Element.html("<a>${currentPage.simpleType}</a>")
      ..onClick.listen((_) => changePage(location));
    return link; 
  }
}

/**
 * Creates a new link to the [parameter]'s type and adds it to [suffix]. 
 */
void addParameter(Parameter parameter, Element suffix) {
  var location = parameter.location;
  if (location == null) {
    suffix.appendText("${parameter.simpleType} ");
  } else {
    var link = new Element.html("<a>${parameter.simpleType}</a>")
    ..onClick.listen((_) => changePage(location));
    suffix.append(link);
    suffix.appendText(" ");
  }
  suffix.appendText(parameter.name);
}

/**
 * Generates an HTML [Element] with proper links based on the
 * type of the method's parameters.
 */
// Cannot go in lib/item.dart since web/app.dart cannot be imported.
Element getSuffix() {
  var parameters = currentPage.parameters;
  var suffix = new ParagraphElement()
    ..appendText("(");
  var required = parameters.where((element) => !element.isOptional);
  var optional = parameters.where((element) => element.isOptional);
  required.forEach((parameter) {
    addParameter(parameter, suffix);
    if (parameter != required.last || !optional.isEmpty) {
      suffix.appendText(', ');
    }
  });
  if (!optional.isEmpty) {
    optional.first.isNamed ? suffix.appendText("{") : suffix.appendText("[");
    optional.forEach((parameter) {
      addParameter(parameter, suffix);
      if (parameter != optional.last) {
        suffix.appendText(', ');
      }
    });
    optional.first.isNamed ? suffix.appendText("}") : suffix.appendText("]");
  }
  suffix.appendText(")");
  return suffix;
}

/**
 * Creates an HTML [Element] for the currentPage's comment and adds it.
 */
void loadComment() {
  var section = query('.description');
  section.children.clear();
  if (currentPage.comment != null && currentPage.comment != "") {
    section.children.add(new Element.html(currentPage.comment));
  }
}

/**
 * Creates an HTML [Element] for interfaces and adds it to [location].
 */
void loadClass(Element location) {
  var links = currentPage.implemented;
  var paragraph = new ParagraphElement();
  if (!links.isEmpty) {
    paragraph.appendText("Implements: ");
    location.children.add(paragraph);
  }
  links.forEach((element) {
    var newPage = pageIndex[element];
    var link = new Element.html("<a>${newPage.simpleName}</a>")
    ..onClick.listen((_) => changePage(newPage));
    paragraph.append(link);
    if (element != links.last) {
      paragraph.appendText(", ");
    }
  });
}

/**
 * Loads proper comments and method/function descriptors for links and viewing.
 */
void loadValues() {
  loadComment();
  var descriptors = queryAll('.descriptor');
  descriptors.forEach((element) => element.children.clear());
  
  if (currentPage is Method) {
    descriptors[0].children.add(getPrefix());
    descriptors[1].children.add(getSuffix());
  } else if (currentPage is Class) {
    loadClass(descriptors[1]);
  } else if (currentPage is Variable) {
    descriptors[0].children.add(getPrefix());
  }
}

// Builds hierarchy, sets up listener for browser navigation, and loads initial
// values for viewing and linking.
main() {
  var sourceYaml = getYamlFile(sourcePath);
  sourceYaml.then((response) {
    currentPage = loadData(response);
    homePage = currentPage;
    buildHierarchy(homePage, homePage);
    loadValues();
  });
  
  // Handles browser navigation.
  window.onPopState.listen((event) {
    if (event.state != null) {
      if (event.state != "") {
        changePageWithoutState(pageIndex[event.state]);
      } 
    } else {
      changePageWithoutState(homePage);
    }
  });
}