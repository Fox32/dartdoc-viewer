/**
 * This application displays documentation generated by the docgen tool
 * found at dart-repo/dart/pkg/docgen. 
 * 
 * The Yaml file outputted by the docgen tool will be read in to 
 * generate [Page] and [Category] and [CompositeContainer]. 
 * Pages, Categories and CategoryItems are used to format and layout the page. 
 */
// TODO(janicejl): Add a link to the dart docgen landing page in future. 
library dartdoc_viewer;

import 'dart:html';
import 'package:web_ui/web_ui.dart';
import 'package:dartdoc_viewer/data.dart';
import 'package:dartdoc_viewer/item.dart';
import 'package:dartdoc_viewer/read_yaml.dart';

// TODO(janicejl): YAML path should not be hardcoded. 
// Path to the YAML file being read in. 
const sourcePath = '../../test/yaml/large_test.yaml';

// Function to set the title of the current page. 
String get title => currentPage == null ? '' : currentPage.decoratedName;

// The correct comment for the current page.
String get comment => currentPage != null ? currentPage.comment : '';

// The homepage from which every [Item] can be reached.
@observable Item homePage;

// The current page being shown.
@observable Item currentPage;

/**
 * Changes the currentPage to the page of the item clicked
 * without pushing state onto the history.
 */
changePageWithoutState(Item page) {
  if (page != null) {
    currentPage = page;
    update();
  }
}

/**
 * Pushes state onto the history before updating the [currentPage].
 */
changePage(Item page) {
  if (page != null && currentPage != page) {
    var state = page.path;
    var title = state.substring(0, state.length - 1);
    window.history.pushState(state, title, '/#$state');
  }
  changePageWithoutState(page);
}

/**
 * Creates a list of [Item] objects from the [path] describing the
 * path to a particular [Item] object.
 */
List<Item> getBreadcrumbs(String path) {
  var breadcrumbs = [];
  // Matches alphanumeric variable/method names ending with a '/'.  
  var regex = new RegExp(r'(_?([a-zA-Z0-9]+)=?)/');
  var matches = regex.allMatches(path);
  var currentPath = '';
  matches.forEach((match) {
    currentPath = '$currentPath${match.group(0)}';
    breadcrumbs.add(pageIndex[currentPath]);
  });
  return breadcrumbs;
}

/**
 * Runs through the member structure and creates path information and
 * populates the [pageIndex] map for proper linking.
 */
void buildHierarchy(Container page, Item previous) {
  if (page is Item) {
    page.path = previous.path == null ?
        '${page.name}/' : '${previous.path}${page.name}/';
    pageIndex[page.path] = page;
    page.content.forEach((subChild) {
      buildHierarchy(subChild, page);
    });
  } else if (page is Category) {
    page.content.forEach((subChild) {
      buildHierarchy(subChild, previous);
    });
  }
}

/// Adds the correct interfaces to [postDescriptor].
void _updateInterfaces(Element postDescriptor) {
  var interfaces = currentPage.implements;
  var paragraph = new ParagraphElement();
  if (!interfaces.isEmpty) {
    paragraph.appendText('Implements: ');
    postDescriptor.children.add(paragraph);
  }
  interfaces.forEach((element) {
    var link = new Element.html('<a>${element.simpleType}</a>')
      ..onClick.listen((_) => changePage(element.location));
    paragraph.append(link);
    if (element != interfaces.last) {
      paragraph.appendText(', ');
    }
  });
}

/// Generates an HTML [Element] given a [LinkableType].
Element _getType(LinkableType type) {
  if (type.location == null) {
    return new Element.html('<p>${type.simpleType}</p>');
  } else {
    var link = new Element.html('<a>${type.simpleType}</a>')
      ..onClick.listen((_) => changePage(type.location));
    return link; 
  }
}

/// Adds a single parameter to [postData].
void addParameter(Parameter parameter, Element postData) {
  if (parameter.type.location != null) {
    postData.append(_getType(parameter.type));
  } else {
    postData.appendText(parameter.type.simpleType);
  }
  postData.appendText(' ${parameter.decoratedName}');
}

/// Adds the correct parameters to [postDescriptor].
void _updateParameters(Element postDescriptor) {
  var required = currentPage.parameters.where((item) => !item.isOptional);
  var optional = currentPage.parameters.where((item) => item.isOptional);
  var postData = new ParagraphElement()
    ..appendText('(');
  required.forEach((parameter) {
    addParameter(parameter, postData);
    if (parameter != required.last || !optional.isEmpty) {
      postData.appendText(', ');
    }
  });
  if (!optional.isEmpty) {
    optional.first.isNamed ? 
        postData.appendText('{') : postData.appendText('[');
    optional.forEach((parameter) {
      addParameter(parameter, postData);
      if (parameter != optional.last) postData.appendText(', ');
    });
    optional.first.isNamed ? 
        postData.appendText('}') : postData.appendText(']');
  }
  postData.appendText(')');
  postDescriptor.children.add(postData);
}

/// Adds the correct comment to [description].
void _updateComment() {
  var description = query('.description');
  description.children.clear();
  if (currentPage.comment != null && currentPage.comment != '') {
    description.children.add(new Element.html(currentPage.comment));
  }
}

/**
 * Update the comment and descriptor tags to match the current page.
 */
void update() {
  _updateComment();
  var descriptors = queryAll('.descriptor');
  var preDescriptor = descriptors[0];
  var postDescriptor = descriptors[1];
  preDescriptor.children.clear();
  postDescriptor.children.clear();
  if (currentPage is Method) {
    preDescriptor.children.add(_getType(currentPage.type));
    _updateParameters(postDescriptor);
  } else if (currentPage is Class) {
    _updateInterfaces(postDescriptor);
  }
}

// Builds hierarchy, sets up listener for browser navigation, and loads initial
// values for viewing and linking.
main() {
  var sourceYaml = getYamlFile(sourcePath);
  sourceYaml.then((response) {
    currentPage = loadData(response);
    homePage = currentPage;
    buildHierarchy(homePage, homePage);
    update();
  });
  
  // Handles browser navigation.
  window.onPopState.listen((event) {
    if (event.state != null) {
      if (event.state != '') {
        changePageWithoutState(pageIndex[event.state]);
      } 
    } else {
      changePageWithoutState(homePage);
    }
  });
}